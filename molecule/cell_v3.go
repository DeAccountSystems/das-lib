// Generated by Molecule 0.7.2
// Generated by Moleculec-Go 0.1.8

package molecule

import (
	"bytes"
	"errors"
	"strconv"
	"strings"
)

type AccountCellDataV3Builder struct {
	id                       AccountId
	account                  AccountChars
	registered_at            Uint64
	last_transfer_account_at Uint64
	last_edit_manager_at     Uint64
	last_edit_records_at     Uint64
	status                   Uint8
	records                  Records
	enable_sub_account       Uint8
	renew_sub_account_price  Uint64
}

func (s *AccountCellDataV3Builder) Build() AccountCellDataV3 {
	b := new(bytes.Buffer)

	totalSize := HeaderSizeUint * (10 + 1)
	offsets := make([]uint32, 0, 10)

	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.id.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.account.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.registered_at.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.last_transfer_account_at.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.last_edit_manager_at.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.last_edit_records_at.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.status.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.records.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.enable_sub_account.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.renew_sub_account_price.AsSlice()))

	b.Write(packNumber(Number(totalSize)))

	for i := 0; i < len(offsets); i++ {
		b.Write(packNumber(Number(offsets[i])))
	}

	b.Write(s.id.AsSlice())
	b.Write(s.account.AsSlice())
	b.Write(s.registered_at.AsSlice())
	b.Write(s.last_transfer_account_at.AsSlice())
	b.Write(s.last_edit_manager_at.AsSlice())
	b.Write(s.last_edit_records_at.AsSlice())
	b.Write(s.status.AsSlice())
	b.Write(s.records.AsSlice())
	b.Write(s.enable_sub_account.AsSlice())
	b.Write(s.renew_sub_account_price.AsSlice())
	return AccountCellDataV3{inner: b.Bytes()}
}

func (s *AccountCellDataV3Builder) Id(v AccountId) *AccountCellDataV3Builder {
	s.id = v
	return s
}

func (s *AccountCellDataV3Builder) Account(v AccountChars) *AccountCellDataV3Builder {
	s.account = v
	return s
}

func (s *AccountCellDataV3Builder) RegisteredAt(v Uint64) *AccountCellDataV3Builder {
	s.registered_at = v
	return s
}

func (s *AccountCellDataV3Builder) LastTransferAccountAt(v Uint64) *AccountCellDataV3Builder {
	s.last_transfer_account_at = v
	return s
}

func (s *AccountCellDataV3Builder) LastEditManagerAt(v Uint64) *AccountCellDataV3Builder {
	s.last_edit_manager_at = v
	return s
}

func (s *AccountCellDataV3Builder) LastEditRecordsAt(v Uint64) *AccountCellDataV3Builder {
	s.last_edit_records_at = v
	return s
}

func (s *AccountCellDataV3Builder) Status(v Uint8) *AccountCellDataV3Builder {
	s.status = v
	return s
}

func (s *AccountCellDataV3Builder) Records(v Records) *AccountCellDataV3Builder {
	s.records = v
	return s
}

func (s *AccountCellDataV3Builder) EnableSubAccount(v Uint8) *AccountCellDataV3Builder {
	s.enable_sub_account = v
	return s
}

func (s *AccountCellDataV3Builder) RenewSubAccountPrice(v Uint64) *AccountCellDataV3Builder {
	s.renew_sub_account_price = v
	return s
}

func NewAccountCellDataV3Builder() *AccountCellDataV3Builder {
	return &AccountCellDataV3Builder{id: AccountIdDefault(), account: AccountCharsDefault(), registered_at: Uint64Default(), last_transfer_account_at: Uint64Default(), last_edit_manager_at: Uint64Default(), last_edit_records_at: Uint64Default(), status: Uint8Default(), records: RecordsDefault(), enable_sub_account: Uint8Default(), renew_sub_account_price: Uint64Default()}
}

type AccountCellDataV3 struct {
	inner []byte
}

func AccountCellDataV3FromSliceUnchecked(slice []byte) *AccountCellDataV3 {
	return &AccountCellDataV3{inner: slice}
}
func (s *AccountCellDataV3) AsSlice() []byte {
	return s.inner
}

func AccountCellDataV3Default() AccountCellDataV3 {
	return *AccountCellDataV3FromSliceUnchecked([]byte{114, 0, 0, 0, 44, 0, 0, 0, 64, 0, 0, 0, 68, 0, 0, 0, 76, 0, 0, 0, 84, 0, 0, 0, 92, 0, 0, 0, 100, 0, 0, 0, 101, 0, 0, 0, 105, 0, 0, 0, 106, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0})
}

func AccountCellDataV3FromSlice(slice []byte, compatible bool) (*AccountCellDataV3, error) {
	sliceLen := len(slice)
	if uint32(sliceLen) < HeaderSizeUint {
		errMsg := strings.Join([]string{"HeaderIsBroken", "AccountCellDataV3", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}

	totalSize := unpackNumber(slice)
	if Number(sliceLen) != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "AccountCellDataV3", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}

	if uint32(sliceLen) == HeaderSizeUint && 10 == 0 {
		return &AccountCellDataV3{inner: slice}, nil
	}

	if uint32(sliceLen) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "AccountCellDataV3", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	offsetFirst := unpackNumber(slice[HeaderSizeUint:])
	if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"OffsetsNotMatch", "AccountCellDataV3", strconv.Itoa(int(offsetFirst % 4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	if sliceLen < int(offsetFirst) {
		errMsg := strings.Join([]string{"HeaderIsBroken", "AccountCellDataV3", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
		return nil, errors.New(errMsg)
	}

	fieldCount := uint32(offsetFirst)/HeaderSizeUint - 1
	if fieldCount < 10 {
		return nil, errors.New("FieldCountNotMatch")
	} else if !compatible && fieldCount > 10 {
		return nil, errors.New("FieldCountNotMatch")
	}

	offsets := make([]uint32, fieldCount)

	for i := 0; i < int(fieldCount); i++ {
		offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
	}
	offsets = append(offsets, uint32(totalSize))

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 && offsets[i-1] > offsets[i] {
			return nil, errors.New("OffsetsNotMatch")
		}
	}

	var err error

	_, err = AccountIdFromSlice(slice[offsets[0]:offsets[1]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = AccountCharsFromSlice(slice[offsets[1]:offsets[2]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = Uint64FromSlice(slice[offsets[2]:offsets[3]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = Uint64FromSlice(slice[offsets[3]:offsets[4]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = Uint64FromSlice(slice[offsets[4]:offsets[5]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = Uint64FromSlice(slice[offsets[5]:offsets[6]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = Uint8FromSlice(slice[offsets[6]:offsets[7]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = RecordsFromSlice(slice[offsets[7]:offsets[8]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = Uint8FromSlice(slice[offsets[8]:offsets[9]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = Uint64FromSlice(slice[offsets[9]:offsets[10]], compatible)
	if err != nil {
		return nil, err
	}

	return &AccountCellDataV3{inner: slice}, nil
}

func (s *AccountCellDataV3) TotalSize() uint {
	return uint(unpackNumber(s.inner))
}
func (s *AccountCellDataV3) FieldCount() uint {
	var number uint = 0
	if uint32(s.TotalSize()) == HeaderSizeUint {
		return number
	}
	number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
	return number
}
func (s *AccountCellDataV3) Len() uint {
	return s.FieldCount()
}
func (s *AccountCellDataV3) IsEmpty() bool {
	return s.Len() == 0
}
func (s *AccountCellDataV3) CountExtraFields() uint {
	return s.FieldCount() - 10
}

func (s *AccountCellDataV3) HasExtraFields() bool {
	return 10 != s.FieldCount()
}

func (s *AccountCellDataV3) Id() *AccountId {
	start := unpackNumber(s.inner[4:])
	end := unpackNumber(s.inner[8:])
	return AccountIdFromSliceUnchecked(s.inner[start:end])
}

func (s *AccountCellDataV3) Account() *AccountChars {
	start := unpackNumber(s.inner[8:])
	end := unpackNumber(s.inner[12:])
	return AccountCharsFromSliceUnchecked(s.inner[start:end])
}

func (s *AccountCellDataV3) RegisteredAt() *Uint64 {
	start := unpackNumber(s.inner[12:])
	end := unpackNumber(s.inner[16:])
	return Uint64FromSliceUnchecked(s.inner[start:end])
}

func (s *AccountCellDataV3) LastTransferAccountAt() *Uint64 {
	start := unpackNumber(s.inner[16:])
	end := unpackNumber(s.inner[20:])
	return Uint64FromSliceUnchecked(s.inner[start:end])
}

func (s *AccountCellDataV3) LastEditManagerAt() *Uint64 {
	start := unpackNumber(s.inner[20:])
	end := unpackNumber(s.inner[24:])
	return Uint64FromSliceUnchecked(s.inner[start:end])
}

func (s *AccountCellDataV3) LastEditRecordsAt() *Uint64 {
	start := unpackNumber(s.inner[24:])
	end := unpackNumber(s.inner[28:])
	return Uint64FromSliceUnchecked(s.inner[start:end])
}

func (s *AccountCellDataV3) Status() *Uint8 {
	start := unpackNumber(s.inner[28:])
	end := unpackNumber(s.inner[32:])
	return Uint8FromSliceUnchecked(s.inner[start:end])
}

func (s *AccountCellDataV3) Records() *Records {
	start := unpackNumber(s.inner[32:])
	end := unpackNumber(s.inner[36:])
	return RecordsFromSliceUnchecked(s.inner[start:end])
}

func (s *AccountCellDataV3) EnableSubAccount() *Uint8 {
	start := unpackNumber(s.inner[36:])
	end := unpackNumber(s.inner[40:])
	return Uint8FromSliceUnchecked(s.inner[start:end])
}

func (s *AccountCellDataV3) RenewSubAccountPrice() *Uint64 {
	var ret *Uint64
	start := unpackNumber(s.inner[40:])
	if s.HasExtraFields() {
		end := unpackNumber(s.inner[44:])
		ret = Uint64FromSliceUnchecked(s.inner[start:end])
	} else {
		ret = Uint64FromSliceUnchecked(s.inner[start:])
	}
	return ret
}

func (s *AccountCellDataV3) AsBuilder() AccountCellDataV3Builder {
	ret := NewAccountCellDataV3Builder().Id(*s.Id()).Account(*s.Account()).RegisteredAt(*s.RegisteredAt()).LastTransferAccountAt(*s.LastTransferAccountAt()).LastEditManagerAt(*s.LastEditManagerAt()).LastEditRecordsAt(*s.LastEditRecordsAt()).Status(*s.Status()).Records(*s.Records()).EnableSubAccount(*s.EnableSubAccount()).RenewSubAccountPrice(*s.RenewSubAccountPrice())
	return *ret
}

type PreAccountCellDataV3Builder struct {
	account             AccountChars
	refund_lock         Script
	owner_lock_args     Bytes
	inviter_id          Bytes
	inviter_lock        ScriptOpt
	channel_lock        ScriptOpt
	price               PriceConfig
	quote               Uint64
	invited_discount    Uint32
	created_at          Uint64
	initial_records     Records
	initial_cross_chain ChainId
}

func (s *PreAccountCellDataV3Builder) Build() PreAccountCellDataV3 {
	b := new(bytes.Buffer)

	totalSize := HeaderSizeUint * (12 + 1)
	offsets := make([]uint32, 0, 12)

	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.account.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.refund_lock.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.owner_lock_args.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.inviter_id.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.inviter_lock.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.channel_lock.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.price.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.quote.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.invited_discount.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.created_at.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.initial_records.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.initial_cross_chain.AsSlice()))

	b.Write(packNumber(Number(totalSize)))

	for i := 0; i < len(offsets); i++ {
		b.Write(packNumber(Number(offsets[i])))
	}

	b.Write(s.account.AsSlice())
	b.Write(s.refund_lock.AsSlice())
	b.Write(s.owner_lock_args.AsSlice())
	b.Write(s.inviter_id.AsSlice())
	b.Write(s.inviter_lock.AsSlice())
	b.Write(s.channel_lock.AsSlice())
	b.Write(s.price.AsSlice())
	b.Write(s.quote.AsSlice())
	b.Write(s.invited_discount.AsSlice())
	b.Write(s.created_at.AsSlice())
	b.Write(s.initial_records.AsSlice())
	b.Write(s.initial_cross_chain.AsSlice())
	return PreAccountCellDataV3{inner: b.Bytes()}
}

func (s *PreAccountCellDataV3Builder) Account(v AccountChars) *PreAccountCellDataV3Builder {
	s.account = v
	return s
}

func (s *PreAccountCellDataV3Builder) RefundLock(v Script) *PreAccountCellDataV3Builder {
	s.refund_lock = v
	return s
}

func (s *PreAccountCellDataV3Builder) OwnerLockArgs(v Bytes) *PreAccountCellDataV3Builder {
	s.owner_lock_args = v
	return s
}

func (s *PreAccountCellDataV3Builder) InviterId(v Bytes) *PreAccountCellDataV3Builder {
	s.inviter_id = v
	return s
}

func (s *PreAccountCellDataV3Builder) InviterLock(v ScriptOpt) *PreAccountCellDataV3Builder {
	s.inviter_lock = v
	return s
}

func (s *PreAccountCellDataV3Builder) ChannelLock(v ScriptOpt) *PreAccountCellDataV3Builder {
	s.channel_lock = v
	return s
}

func (s *PreAccountCellDataV3Builder) Price(v PriceConfig) *PreAccountCellDataV3Builder {
	s.price = v
	return s
}

func (s *PreAccountCellDataV3Builder) Quote(v Uint64) *PreAccountCellDataV3Builder {
	s.quote = v
	return s
}

func (s *PreAccountCellDataV3Builder) InvitedDiscount(v Uint32) *PreAccountCellDataV3Builder {
	s.invited_discount = v
	return s
}

func (s *PreAccountCellDataV3Builder) CreatedAt(v Uint64) *PreAccountCellDataV3Builder {
	s.created_at = v
	return s
}

func (s *PreAccountCellDataV3Builder) InitialRecords(v Records) *PreAccountCellDataV3Builder {
	s.initial_records = v
	return s
}

func (s *PreAccountCellDataV3Builder) InitialCrossChain(v ChainId) *PreAccountCellDataV3Builder {
	s.initial_cross_chain = v
	return s
}

func NewPreAccountCellDataV3Builder() *PreAccountCellDataV3Builder {
	return &PreAccountCellDataV3Builder{account: AccountCharsDefault(), refund_lock: ScriptDefault(), owner_lock_args: BytesDefault(), inviter_id: BytesDefault(), inviter_lock: ScriptOptDefault(), channel_lock: ScriptOptDefault(), price: PriceConfigDefault(), quote: Uint64Default(), invited_discount: Uint32Default(), created_at: Uint64Default(), initial_records: RecordsDefault(), initial_cross_chain: ChainIdDefault()}
}

type PreAccountCellDataV3 struct {
	inner []byte
}

func PreAccountCellDataV3FromSliceUnchecked(slice []byte) *PreAccountCellDataV3 {
	return &PreAccountCellDataV3{inner: slice}
}
func (s *PreAccountCellDataV3) AsSlice() []byte {
	return s.inner
}

func PreAccountCellDataV3Default() PreAccountCellDataV3 {
	return *PreAccountCellDataV3FromSliceUnchecked([]byte{207, 0, 0, 0, 52, 0, 0, 0, 56, 0, 0, 0, 109, 0, 0, 0, 113, 0, 0, 0, 117, 0, 0, 0, 117, 0, 0, 0, 117, 0, 0, 0, 150, 0, 0, 0, 158, 0, 0, 0, 162, 0, 0, 0, 170, 0, 0, 0, 174, 0, 0, 0, 4, 0, 0, 0, 53, 0, 0, 0, 16, 0, 0, 0, 48, 0, 0, 0, 49, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 33, 0, 0, 0, 16, 0, 0, 0, 17, 0, 0, 0, 25, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 33, 0, 0, 0, 16, 0, 0, 0, 17, 0, 0, 0, 25, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0})
}

func PreAccountCellDataV3FromSlice(slice []byte, compatible bool) (*PreAccountCellDataV3, error) {
	sliceLen := len(slice)
	if uint32(sliceLen) < HeaderSizeUint {
		errMsg := strings.Join([]string{"HeaderIsBroken", "PreAccountCellDataV3", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}

	totalSize := unpackNumber(slice)
	if Number(sliceLen) != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "PreAccountCellDataV3", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}

	if uint32(sliceLen) == HeaderSizeUint && 12 == 0 {
		return &PreAccountCellDataV3{inner: slice}, nil
	}

	if uint32(sliceLen) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "PreAccountCellDataV3", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	offsetFirst := unpackNumber(slice[HeaderSizeUint:])
	if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"OffsetsNotMatch", "PreAccountCellDataV3", strconv.Itoa(int(offsetFirst % 4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	if sliceLen < int(offsetFirst) {
		errMsg := strings.Join([]string{"HeaderIsBroken", "PreAccountCellDataV3", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
		return nil, errors.New(errMsg)
	}

	fieldCount := uint32(offsetFirst)/HeaderSizeUint - 1
	if fieldCount < 12 {
		return nil, errors.New("FieldCountNotMatch")
	} else if !compatible && fieldCount > 12 {
		return nil, errors.New("FieldCountNotMatch")
	}

	offsets := make([]uint32, fieldCount)

	for i := 0; i < int(fieldCount); i++ {
		offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
	}
	offsets = append(offsets, uint32(totalSize))

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 && offsets[i-1] > offsets[i] {
			return nil, errors.New("OffsetsNotMatch")
		}
	}

	var err error

	_, err = AccountCharsFromSlice(slice[offsets[0]:offsets[1]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = ScriptFromSlice(slice[offsets[1]:offsets[2]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = BytesFromSlice(slice[offsets[2]:offsets[3]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = BytesFromSlice(slice[offsets[3]:offsets[4]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = ScriptOptFromSlice(slice[offsets[4]:offsets[5]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = ScriptOptFromSlice(slice[offsets[5]:offsets[6]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = PriceConfigFromSlice(slice[offsets[6]:offsets[7]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = Uint64FromSlice(slice[offsets[7]:offsets[8]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = Uint32FromSlice(slice[offsets[8]:offsets[9]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = Uint64FromSlice(slice[offsets[9]:offsets[10]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = RecordsFromSlice(slice[offsets[10]:offsets[11]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = ChainIdFromSlice(slice[offsets[11]:offsets[12]], compatible)
	if err != nil {
		return nil, err
	}

	return &PreAccountCellDataV3{inner: slice}, nil
}

func (s *PreAccountCellDataV3) TotalSize() uint {
	return uint(unpackNumber(s.inner))
}
func (s *PreAccountCellDataV3) FieldCount() uint {
	var number uint = 0
	if uint32(s.TotalSize()) == HeaderSizeUint {
		return number
	}
	number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
	return number
}
func (s *PreAccountCellDataV3) Len() uint {
	return s.FieldCount()
}
func (s *PreAccountCellDataV3) IsEmpty() bool {
	return s.Len() == 0
}
func (s *PreAccountCellDataV3) CountExtraFields() uint {
	return s.FieldCount() - 12
}

func (s *PreAccountCellDataV3) HasExtraFields() bool {
	return 12 != s.FieldCount()
}

func (s *PreAccountCellDataV3) Account() *AccountChars {
	start := unpackNumber(s.inner[4:])
	end := unpackNumber(s.inner[8:])
	return AccountCharsFromSliceUnchecked(s.inner[start:end])
}

func (s *PreAccountCellDataV3) RefundLock() *Script {
	start := unpackNumber(s.inner[8:])
	end := unpackNumber(s.inner[12:])
	return ScriptFromSliceUnchecked(s.inner[start:end])
}

func (s *PreAccountCellDataV3) OwnerLockArgs() *Bytes {
	start := unpackNumber(s.inner[12:])
	end := unpackNumber(s.inner[16:])
	return BytesFromSliceUnchecked(s.inner[start:end])
}

func (s *PreAccountCellDataV3) InviterId() *Bytes {
	start := unpackNumber(s.inner[16:])
	end := unpackNumber(s.inner[20:])
	return BytesFromSliceUnchecked(s.inner[start:end])
}

func (s *PreAccountCellDataV3) InviterLock() *ScriptOpt {
	start := unpackNumber(s.inner[20:])
	end := unpackNumber(s.inner[24:])
	return ScriptOptFromSliceUnchecked(s.inner[start:end])
}

func (s *PreAccountCellDataV3) ChannelLock() *ScriptOpt {
	start := unpackNumber(s.inner[24:])
	end := unpackNumber(s.inner[28:])
	return ScriptOptFromSliceUnchecked(s.inner[start:end])
}

func (s *PreAccountCellDataV3) Price() *PriceConfig {
	start := unpackNumber(s.inner[28:])
	end := unpackNumber(s.inner[32:])
	return PriceConfigFromSliceUnchecked(s.inner[start:end])
}

func (s *PreAccountCellDataV3) Quote() *Uint64 {
	start := unpackNumber(s.inner[32:])
	end := unpackNumber(s.inner[36:])
	return Uint64FromSliceUnchecked(s.inner[start:end])
}

func (s *PreAccountCellDataV3) InvitedDiscount() *Uint32 {
	start := unpackNumber(s.inner[36:])
	end := unpackNumber(s.inner[40:])
	return Uint32FromSliceUnchecked(s.inner[start:end])
}

func (s *PreAccountCellDataV3) CreatedAt() *Uint64 {
	start := unpackNumber(s.inner[40:])
	end := unpackNumber(s.inner[44:])
	return Uint64FromSliceUnchecked(s.inner[start:end])
}

func (s *PreAccountCellDataV3) InitialRecords() *Records {
	start := unpackNumber(s.inner[44:])
	end := unpackNumber(s.inner[48:])
	return RecordsFromSliceUnchecked(s.inner[start:end])
}

func (s *PreAccountCellDataV3) InitialCrossChain() *ChainId {
	var ret *ChainId
	start := unpackNumber(s.inner[48:])
	if s.HasExtraFields() {
		end := unpackNumber(s.inner[52:])
		ret = ChainIdFromSliceUnchecked(s.inner[start:end])
	} else {
		ret = ChainIdFromSliceUnchecked(s.inner[start:])
	}
	return ret
}

func (s *PreAccountCellDataV3) AsBuilder() PreAccountCellDataV3Builder {
	ret := NewPreAccountCellDataV3Builder().Account(*s.Account()).RefundLock(*s.RefundLock()).OwnerLockArgs(*s.OwnerLockArgs()).InviterId(*s.InviterId()).InviterLock(*s.InviterLock()).ChannelLock(*s.ChannelLock()).Price(*s.Price()).Quote(*s.Quote()).InvitedDiscount(*s.InvitedDiscount()).CreatedAt(*s.CreatedAt()).InitialRecords(*s.InitialRecords()).InitialCrossChain(*s.InitialCrossChain())
	return *ret
}

type ChainIdBuilder struct {
	checked   Uint8
	coin_type Uint64
	chain_id  Uint64
}

func (s *ChainIdBuilder) Build() ChainId {
	b := new(bytes.Buffer)

	totalSize := HeaderSizeUint * (3 + 1)
	offsets := make([]uint32, 0, 3)

	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.checked.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.coin_type.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.chain_id.AsSlice()))

	b.Write(packNumber(Number(totalSize)))

	for i := 0; i < len(offsets); i++ {
		b.Write(packNumber(Number(offsets[i])))
	}

	b.Write(s.checked.AsSlice())
	b.Write(s.coin_type.AsSlice())
	b.Write(s.chain_id.AsSlice())
	return ChainId{inner: b.Bytes()}
}

func (s *ChainIdBuilder) Checked(v Uint8) *ChainIdBuilder {
	s.checked = v
	return s
}

func (s *ChainIdBuilder) CoinType(v Uint64) *ChainIdBuilder {
	s.coin_type = v
	return s
}

func (s *ChainIdBuilder) ChainId(v Uint64) *ChainIdBuilder {
	s.chain_id = v
	return s
}

func NewChainIdBuilder() *ChainIdBuilder {
	return &ChainIdBuilder{checked: Uint8Default(), coin_type: Uint64Default(), chain_id: Uint64Default()}
}

type ChainId struct {
	inner []byte
}

func ChainIdFromSliceUnchecked(slice []byte) *ChainId {
	return &ChainId{inner: slice}
}
func (s *ChainId) AsSlice() []byte {
	return s.inner
}

func ChainIdDefault() ChainId {
	return *ChainIdFromSliceUnchecked([]byte{33, 0, 0, 0, 16, 0, 0, 0, 17, 0, 0, 0, 25, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0})
}

func ChainIdFromSlice(slice []byte, compatible bool) (*ChainId, error) {
	sliceLen := len(slice)
	if uint32(sliceLen) < HeaderSizeUint {
		errMsg := strings.Join([]string{"HeaderIsBroken", "ChainId", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}

	totalSize := unpackNumber(slice)
	if Number(sliceLen) != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "ChainId", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}

	if uint32(sliceLen) == HeaderSizeUint && 3 == 0 {
		return &ChainId{inner: slice}, nil
	}

	if uint32(sliceLen) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "ChainId", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	offsetFirst := unpackNumber(slice[HeaderSizeUint:])
	if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"OffsetsNotMatch", "ChainId", strconv.Itoa(int(offsetFirst % 4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	if sliceLen < int(offsetFirst) {
		errMsg := strings.Join([]string{"HeaderIsBroken", "ChainId", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
		return nil, errors.New(errMsg)
	}

	fieldCount := uint32(offsetFirst)/HeaderSizeUint - 1
	if fieldCount < 3 {
		return nil, errors.New("FieldCountNotMatch")
	} else if !compatible && fieldCount > 3 {
		return nil, errors.New("FieldCountNotMatch")
	}

	offsets := make([]uint32, fieldCount)

	for i := 0; i < int(fieldCount); i++ {
		offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
	}
	offsets = append(offsets, uint32(totalSize))

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 && offsets[i-1] > offsets[i] {
			return nil, errors.New("OffsetsNotMatch")
		}
	}

	var err error

	_, err = Uint8FromSlice(slice[offsets[0]:offsets[1]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = Uint64FromSlice(slice[offsets[1]:offsets[2]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = Uint64FromSlice(slice[offsets[2]:offsets[3]], compatible)
	if err != nil {
		return nil, err
	}

	return &ChainId{inner: slice}, nil
}

func (s *ChainId) TotalSize() uint {
	return uint(unpackNumber(s.inner))
}
func (s *ChainId) FieldCount() uint {
	var number uint = 0
	if uint32(s.TotalSize()) == HeaderSizeUint {
		return number
	}
	number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
	return number
}
func (s *ChainId) Len() uint {
	return s.FieldCount()
}
func (s *ChainId) IsEmpty() bool {
	return s.Len() == 0
}
func (s *ChainId) CountExtraFields() uint {
	return s.FieldCount() - 3
}

func (s *ChainId) HasExtraFields() bool {
	return 3 != s.FieldCount()
}

func (s *ChainId) Checked() *Uint8 {
	start := unpackNumber(s.inner[4:])
	end := unpackNumber(s.inner[8:])
	return Uint8FromSliceUnchecked(s.inner[start:end])
}

func (s *ChainId) CoinType() *Uint64 {
	start := unpackNumber(s.inner[8:])
	end := unpackNumber(s.inner[12:])
	return Uint64FromSliceUnchecked(s.inner[start:end])
}

func (s *ChainId) ChainId() *Uint64 {
	var ret *Uint64
	start := unpackNumber(s.inner[12:])
	if s.HasExtraFields() {
		end := unpackNumber(s.inner[16:])
		ret = Uint64FromSliceUnchecked(s.inner[start:end])
	} else {
		ret = Uint64FromSliceUnchecked(s.inner[start:])
	}
	return ret
}

func (s *ChainId) AsBuilder() ChainIdBuilder {
	ret := NewChainIdBuilder().Checked(*s.Checked()).CoinType(*s.CoinType()).ChainId(*s.ChainId())
	return *ret
}
