// Generated by Molecule 0.7.5
// Generated by Moleculec-Go 0.1.11

package molecule

import (
	"bytes"
	"errors"
	"strconv"
	"strings"
)

type ConfigCellMainV1Builder struct {
	status                   Uint8
	type_id_table            TypeIdTableV1
	das_lock_out_point_table DasLockOutPointTableV1
}

func (s *ConfigCellMainV1Builder) Build() ConfigCellMainV1 {
	b := new(bytes.Buffer)

	totalSize := HeaderSizeUint * (3 + 1)
	offsets := make([]uint32, 0, 3)

	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.status.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.type_id_table.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.das_lock_out_point_table.AsSlice()))

	b.Write(packNumber(Number(totalSize)))

	for i := 0; i < len(offsets); i++ {
		b.Write(packNumber(Number(offsets[i])))
	}

	b.Write(s.status.AsSlice())
	b.Write(s.type_id_table.AsSlice())
	b.Write(s.das_lock_out_point_table.AsSlice())
	return ConfigCellMainV1{inner: b.Bytes()}
}

func (s *ConfigCellMainV1Builder) Status(v Uint8) *ConfigCellMainV1Builder {
	s.status = v
	return s
}

func (s *ConfigCellMainV1Builder) TypeIdTable(v TypeIdTableV1) *ConfigCellMainV1Builder {
	s.type_id_table = v
	return s
}

func (s *ConfigCellMainV1Builder) DasLockOutPointTable(v DasLockOutPointTableV1) *ConfigCellMainV1Builder {
	s.das_lock_out_point_table = v
	return s
}

func NewConfigCellMainV1Builder() *ConfigCellMainV1Builder {
	return &ConfigCellMainV1Builder{status: Uint8Default(), type_id_table: TypeIdTableV1Default(), das_lock_out_point_table: DasLockOutPointTableV1Default()}
}

type ConfigCellMainV1 struct {
	inner []byte
}

func ConfigCellMainV1FromSliceUnchecked(slice []byte) *ConfigCellMainV1 {
	return &ConfigCellMainV1{inner: slice}
}
func (s *ConfigCellMainV1) AsSlice() []byte {
	return s.inner
}

func ConfigCellMainV1Default() ConfigCellMainV1 {
	return *ConfigCellMainV1FromSliceUnchecked([]byte{221, 1, 0, 0, 16, 0, 0, 0, 17, 0, 0, 0, 17, 1, 0, 0, 0, 0, 1, 0, 0, 32, 0, 0, 0, 64, 0, 0, 0, 96, 0, 0, 0, 128, 0, 0, 0, 160, 0, 0, 0, 192, 0, 0, 0, 224, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 204, 0, 0, 0, 24, 0, 0, 0, 60, 0, 0, 0, 96, 0, 0, 0, 132, 0, 0, 0, 168, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0})
}

func ConfigCellMainV1FromSlice(slice []byte, compatible bool) (*ConfigCellMainV1, error) {
	sliceLen := len(slice)
	if uint32(sliceLen) < HeaderSizeUint {
		errMsg := strings.Join([]string{"HeaderIsBroken", "ConfigCellMainV1", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}

	totalSize := unpackNumber(slice)
	if Number(sliceLen) != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "ConfigCellMainV1", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}

	if uint32(sliceLen) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "ConfigCellMainV1", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	offsetFirst := unpackNumber(slice[HeaderSizeUint:])
	if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"OffsetsNotMatch", "ConfigCellMainV1", strconv.Itoa(int(offsetFirst % 4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	if sliceLen < int(offsetFirst) {
		errMsg := strings.Join([]string{"HeaderIsBroken", "ConfigCellMainV1", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
		return nil, errors.New(errMsg)
	}

	fieldCount := uint32(offsetFirst)/HeaderSizeUint - 1
	if fieldCount < 3 {
		return nil, errors.New("FieldCountNotMatch")
	} else if !compatible && fieldCount > 3 {
		return nil, errors.New("FieldCountNotMatch")
	}

	offsets := make([]uint32, fieldCount)

	for i := 0; i < int(fieldCount); i++ {
		offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
	}
	offsets = append(offsets, uint32(totalSize))

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 && offsets[i-1] > offsets[i] {
			return nil, errors.New("OffsetsNotMatch")
		}
	}

	var err error

	_, err = Uint8FromSlice(slice[offsets[0]:offsets[1]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = TypeIdTableV1FromSlice(slice[offsets[1]:offsets[2]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = DasLockOutPointTableV1FromSlice(slice[offsets[2]:offsets[3]], compatible)
	if err != nil {
		return nil, err
	}

	return &ConfigCellMainV1{inner: slice}, nil
}

func (s *ConfigCellMainV1) TotalSize() uint {
	return uint(unpackNumber(s.inner))
}
func (s *ConfigCellMainV1) FieldCount() uint {
	var number uint = 0
	if uint32(s.TotalSize()) == HeaderSizeUint {
		return number
	}
	number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
	return number
}
func (s *ConfigCellMainV1) Len() uint {
	return s.FieldCount()
}
func (s *ConfigCellMainV1) IsEmpty() bool {
	return s.Len() == 0
}
func (s *ConfigCellMainV1) CountExtraFields() uint {
	return s.FieldCount() - 3
}

func (s *ConfigCellMainV1) HasExtraFields() bool {
	return 3 != s.FieldCount()
}

func (s *ConfigCellMainV1) Status() *Uint8 {
	start := unpackNumber(s.inner[4:])
	end := unpackNumber(s.inner[8:])
	return Uint8FromSliceUnchecked(s.inner[start:end])
}

func (s *ConfigCellMainV1) TypeIdTable() *TypeIdTableV1 {
	start := unpackNumber(s.inner[8:])
	end := unpackNumber(s.inner[12:])
	return TypeIdTableV1FromSliceUnchecked(s.inner[start:end])
}

func (s *ConfigCellMainV1) DasLockOutPointTable() *DasLockOutPointTableV1 {
	var ret *DasLockOutPointTableV1
	start := unpackNumber(s.inner[12:])
	if s.HasExtraFields() {
		end := unpackNumber(s.inner[16:])
		ret = DasLockOutPointTableV1FromSliceUnchecked(s.inner[start:end])
	} else {
		ret = DasLockOutPointTableV1FromSliceUnchecked(s.inner[start:])
	}
	return ret
}

func (s *ConfigCellMainV1) AsBuilder() ConfigCellMainV1Builder {
	ret := NewConfigCellMainV1Builder().Status(*s.Status()).TypeIdTable(*s.TypeIdTable()).DasLockOutPointTable(*s.DasLockOutPointTable())
	return *ret
}

type TypeIdTableV1Builder struct {
	account_cell        Hash
	apply_register_cell Hash
	bidding_cell        Hash
	income_cell         Hash
	on_sale_cell        Hash
	pre_account_cell    Hash
	proposal_cell       Hash
}

func (s *TypeIdTableV1Builder) Build() TypeIdTableV1 {
	b := new(bytes.Buffer)

	totalSize := HeaderSizeUint * (7 + 1)
	offsets := make([]uint32, 0, 7)

	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.account_cell.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.apply_register_cell.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.bidding_cell.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.income_cell.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.on_sale_cell.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.pre_account_cell.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.proposal_cell.AsSlice()))

	b.Write(packNumber(Number(totalSize)))

	for i := 0; i < len(offsets); i++ {
		b.Write(packNumber(Number(offsets[i])))
	}

	b.Write(s.account_cell.AsSlice())
	b.Write(s.apply_register_cell.AsSlice())
	b.Write(s.bidding_cell.AsSlice())
	b.Write(s.income_cell.AsSlice())
	b.Write(s.on_sale_cell.AsSlice())
	b.Write(s.pre_account_cell.AsSlice())
	b.Write(s.proposal_cell.AsSlice())
	return TypeIdTableV1{inner: b.Bytes()}
}

func (s *TypeIdTableV1Builder) AccountCell(v Hash) *TypeIdTableV1Builder {
	s.account_cell = v
	return s
}

func (s *TypeIdTableV1Builder) ApplyRegisterCell(v Hash) *TypeIdTableV1Builder {
	s.apply_register_cell = v
	return s
}

func (s *TypeIdTableV1Builder) BiddingCell(v Hash) *TypeIdTableV1Builder {
	s.bidding_cell = v
	return s
}

func (s *TypeIdTableV1Builder) IncomeCell(v Hash) *TypeIdTableV1Builder {
	s.income_cell = v
	return s
}

func (s *TypeIdTableV1Builder) OnSaleCell(v Hash) *TypeIdTableV1Builder {
	s.on_sale_cell = v
	return s
}

func (s *TypeIdTableV1Builder) PreAccountCell(v Hash) *TypeIdTableV1Builder {
	s.pre_account_cell = v
	return s
}

func (s *TypeIdTableV1Builder) ProposalCell(v Hash) *TypeIdTableV1Builder {
	s.proposal_cell = v
	return s
}

func NewTypeIdTableV1Builder() *TypeIdTableV1Builder {
	return &TypeIdTableV1Builder{account_cell: HashDefault(), apply_register_cell: HashDefault(), bidding_cell: HashDefault(), income_cell: HashDefault(), on_sale_cell: HashDefault(), pre_account_cell: HashDefault(), proposal_cell: HashDefault()}
}

type TypeIdTableV1 struct {
	inner []byte
}

func TypeIdTableV1FromSliceUnchecked(slice []byte) *TypeIdTableV1 {
	return &TypeIdTableV1{inner: slice}
}
func (s *TypeIdTableV1) AsSlice() []byte {
	return s.inner
}

func TypeIdTableV1Default() TypeIdTableV1 {
	return *TypeIdTableV1FromSliceUnchecked([]byte{0, 1, 0, 0, 32, 0, 0, 0, 64, 0, 0, 0, 96, 0, 0, 0, 128, 0, 0, 0, 160, 0, 0, 0, 192, 0, 0, 0, 224, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0})
}

func TypeIdTableV1FromSlice(slice []byte, compatible bool) (*TypeIdTableV1, error) {
	sliceLen := len(slice)
	if uint32(sliceLen) < HeaderSizeUint {
		errMsg := strings.Join([]string{"HeaderIsBroken", "TypeIdTableV1", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}

	totalSize := unpackNumber(slice)
	if Number(sliceLen) != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "TypeIdTableV1", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}

	if uint32(sliceLen) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "TypeIdTableV1", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	offsetFirst := unpackNumber(slice[HeaderSizeUint:])
	if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"OffsetsNotMatch", "TypeIdTableV1", strconv.Itoa(int(offsetFirst % 4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	if sliceLen < int(offsetFirst) {
		errMsg := strings.Join([]string{"HeaderIsBroken", "TypeIdTableV1", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
		return nil, errors.New(errMsg)
	}

	fieldCount := uint32(offsetFirst)/HeaderSizeUint - 1
	if fieldCount < 7 {
		return nil, errors.New("FieldCountNotMatch")
	} else if !compatible && fieldCount > 7 {
		return nil, errors.New("FieldCountNotMatch")
	}

	offsets := make([]uint32, fieldCount)

	for i := 0; i < int(fieldCount); i++ {
		offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
	}
	offsets = append(offsets, uint32(totalSize))

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 && offsets[i-1] > offsets[i] {
			return nil, errors.New("OffsetsNotMatch")
		}
	}

	var err error

	_, err = HashFromSlice(slice[offsets[0]:offsets[1]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = HashFromSlice(slice[offsets[1]:offsets[2]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = HashFromSlice(slice[offsets[2]:offsets[3]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = HashFromSlice(slice[offsets[3]:offsets[4]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = HashFromSlice(slice[offsets[4]:offsets[5]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = HashFromSlice(slice[offsets[5]:offsets[6]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = HashFromSlice(slice[offsets[6]:offsets[7]], compatible)
	if err != nil {
		return nil, err
	}

	return &TypeIdTableV1{inner: slice}, nil
}

func (s *TypeIdTableV1) TotalSize() uint {
	return uint(unpackNumber(s.inner))
}
func (s *TypeIdTableV1) FieldCount() uint {
	var number uint = 0
	if uint32(s.TotalSize()) == HeaderSizeUint {
		return number
	}
	number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
	return number
}
func (s *TypeIdTableV1) Len() uint {
	return s.FieldCount()
}
func (s *TypeIdTableV1) IsEmpty() bool {
	return s.Len() == 0
}
func (s *TypeIdTableV1) CountExtraFields() uint {
	return s.FieldCount() - 7
}

func (s *TypeIdTableV1) HasExtraFields() bool {
	return 7 != s.FieldCount()
}

func (s *TypeIdTableV1) AccountCell() *Hash {
	start := unpackNumber(s.inner[4:])
	end := unpackNumber(s.inner[8:])
	return HashFromSliceUnchecked(s.inner[start:end])
}

func (s *TypeIdTableV1) ApplyRegisterCell() *Hash {
	start := unpackNumber(s.inner[8:])
	end := unpackNumber(s.inner[12:])
	return HashFromSliceUnchecked(s.inner[start:end])
}

func (s *TypeIdTableV1) BiddingCell() *Hash {
	start := unpackNumber(s.inner[12:])
	end := unpackNumber(s.inner[16:])
	return HashFromSliceUnchecked(s.inner[start:end])
}

func (s *TypeIdTableV1) IncomeCell() *Hash {
	start := unpackNumber(s.inner[16:])
	end := unpackNumber(s.inner[20:])
	return HashFromSliceUnchecked(s.inner[start:end])
}

func (s *TypeIdTableV1) OnSaleCell() *Hash {
	start := unpackNumber(s.inner[20:])
	end := unpackNumber(s.inner[24:])
	return HashFromSliceUnchecked(s.inner[start:end])
}

func (s *TypeIdTableV1) PreAccountCell() *Hash {
	start := unpackNumber(s.inner[24:])
	end := unpackNumber(s.inner[28:])
	return HashFromSliceUnchecked(s.inner[start:end])
}

func (s *TypeIdTableV1) ProposalCell() *Hash {
	var ret *Hash
	start := unpackNumber(s.inner[28:])
	if s.HasExtraFields() {
		end := unpackNumber(s.inner[32:])
		ret = HashFromSliceUnchecked(s.inner[start:end])
	} else {
		ret = HashFromSliceUnchecked(s.inner[start:])
	}
	return ret
}

func (s *TypeIdTableV1) AsBuilder() TypeIdTableV1Builder {
	ret := NewTypeIdTableV1Builder().AccountCell(*s.AccountCell()).ApplyRegisterCell(*s.ApplyRegisterCell()).BiddingCell(*s.BiddingCell()).IncomeCell(*s.IncomeCell()).OnSaleCell(*s.OnSaleCell()).PreAccountCell(*s.PreAccountCell()).ProposalCell(*s.ProposalCell())
	return *ret
}

type DasLockOutPointTableV1Builder struct {
	ckb_signall        OutPoint
	ckb_multisign      OutPoint
	ckb_anyone_can_pay OutPoint
	eth                OutPoint
	tron               OutPoint
}

func (s *DasLockOutPointTableV1Builder) Build() DasLockOutPointTableV1 {
	b := new(bytes.Buffer)

	totalSize := HeaderSizeUint * (5 + 1)
	offsets := make([]uint32, 0, 5)

	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.ckb_signall.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.ckb_multisign.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.ckb_anyone_can_pay.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.eth.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.tron.AsSlice()))

	b.Write(packNumber(Number(totalSize)))

	for i := 0; i < len(offsets); i++ {
		b.Write(packNumber(Number(offsets[i])))
	}

	b.Write(s.ckb_signall.AsSlice())
	b.Write(s.ckb_multisign.AsSlice())
	b.Write(s.ckb_anyone_can_pay.AsSlice())
	b.Write(s.eth.AsSlice())
	b.Write(s.tron.AsSlice())
	return DasLockOutPointTableV1{inner: b.Bytes()}
}

func (s *DasLockOutPointTableV1Builder) CkbSignall(v OutPoint) *DasLockOutPointTableV1Builder {
	s.ckb_signall = v
	return s
}

func (s *DasLockOutPointTableV1Builder) CkbMultisign(v OutPoint) *DasLockOutPointTableV1Builder {
	s.ckb_multisign = v
	return s
}

func (s *DasLockOutPointTableV1Builder) CkbAnyoneCanPay(v OutPoint) *DasLockOutPointTableV1Builder {
	s.ckb_anyone_can_pay = v
	return s
}

func (s *DasLockOutPointTableV1Builder) Eth(v OutPoint) *DasLockOutPointTableV1Builder {
	s.eth = v
	return s
}

func (s *DasLockOutPointTableV1Builder) Tron(v OutPoint) *DasLockOutPointTableV1Builder {
	s.tron = v
	return s
}

func NewDasLockOutPointTableV1Builder() *DasLockOutPointTableV1Builder {
	return &DasLockOutPointTableV1Builder{ckb_signall: OutPointDefault(), ckb_multisign: OutPointDefault(), ckb_anyone_can_pay: OutPointDefault(), eth: OutPointDefault(), tron: OutPointDefault()}
}

type DasLockOutPointTableV1 struct {
	inner []byte
}

func DasLockOutPointTableV1FromSliceUnchecked(slice []byte) *DasLockOutPointTableV1 {
	return &DasLockOutPointTableV1{inner: slice}
}
func (s *DasLockOutPointTableV1) AsSlice() []byte {
	return s.inner
}

func DasLockOutPointTableV1Default() DasLockOutPointTableV1 {
	return *DasLockOutPointTableV1FromSliceUnchecked([]byte{204, 0, 0, 0, 24, 0, 0, 0, 60, 0, 0, 0, 96, 0, 0, 0, 132, 0, 0, 0, 168, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0})
}

func DasLockOutPointTableV1FromSlice(slice []byte, compatible bool) (*DasLockOutPointTableV1, error) {
	sliceLen := len(slice)
	if uint32(sliceLen) < HeaderSizeUint {
		errMsg := strings.Join([]string{"HeaderIsBroken", "DasLockOutPointTableV1", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}

	totalSize := unpackNumber(slice)
	if Number(sliceLen) != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "DasLockOutPointTableV1", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}

	if uint32(sliceLen) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "DasLockOutPointTableV1", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	offsetFirst := unpackNumber(slice[HeaderSizeUint:])
	if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"OffsetsNotMatch", "DasLockOutPointTableV1", strconv.Itoa(int(offsetFirst % 4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	if sliceLen < int(offsetFirst) {
		errMsg := strings.Join([]string{"HeaderIsBroken", "DasLockOutPointTableV1", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
		return nil, errors.New(errMsg)
	}

	fieldCount := uint32(offsetFirst)/HeaderSizeUint - 1
	if fieldCount < 5 {
		return nil, errors.New("FieldCountNotMatch")
	} else if !compatible && fieldCount > 5 {
		return nil, errors.New("FieldCountNotMatch")
	}

	offsets := make([]uint32, fieldCount)

	for i := 0; i < int(fieldCount); i++ {
		offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
	}
	offsets = append(offsets, uint32(totalSize))

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 && offsets[i-1] > offsets[i] {
			return nil, errors.New("OffsetsNotMatch")
		}
	}

	var err error

	_, err = OutPointFromSlice(slice[offsets[0]:offsets[1]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = OutPointFromSlice(slice[offsets[1]:offsets[2]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = OutPointFromSlice(slice[offsets[2]:offsets[3]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = OutPointFromSlice(slice[offsets[3]:offsets[4]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = OutPointFromSlice(slice[offsets[4]:offsets[5]], compatible)
	if err != nil {
		return nil, err
	}

	return &DasLockOutPointTableV1{inner: slice}, nil
}

func (s *DasLockOutPointTableV1) TotalSize() uint {
	return uint(unpackNumber(s.inner))
}
func (s *DasLockOutPointTableV1) FieldCount() uint {
	var number uint = 0
	if uint32(s.TotalSize()) == HeaderSizeUint {
		return number
	}
	number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
	return number
}
func (s *DasLockOutPointTableV1) Len() uint {
	return s.FieldCount()
}
func (s *DasLockOutPointTableV1) IsEmpty() bool {
	return s.Len() == 0
}
func (s *DasLockOutPointTableV1) CountExtraFields() uint {
	return s.FieldCount() - 5
}

func (s *DasLockOutPointTableV1) HasExtraFields() bool {
	return 5 != s.FieldCount()
}

func (s *DasLockOutPointTableV1) CkbSignall() *OutPoint {
	start := unpackNumber(s.inner[4:])
	end := unpackNumber(s.inner[8:])
	return OutPointFromSliceUnchecked(s.inner[start:end])
}

func (s *DasLockOutPointTableV1) CkbMultisign() *OutPoint {
	start := unpackNumber(s.inner[8:])
	end := unpackNumber(s.inner[12:])
	return OutPointFromSliceUnchecked(s.inner[start:end])
}

func (s *DasLockOutPointTableV1) CkbAnyoneCanPay() *OutPoint {
	start := unpackNumber(s.inner[12:])
	end := unpackNumber(s.inner[16:])
	return OutPointFromSliceUnchecked(s.inner[start:end])
}

func (s *DasLockOutPointTableV1) Eth() *OutPoint {
	start := unpackNumber(s.inner[16:])
	end := unpackNumber(s.inner[20:])
	return OutPointFromSliceUnchecked(s.inner[start:end])
}

func (s *DasLockOutPointTableV1) Tron() *OutPoint {
	var ret *OutPoint
	start := unpackNumber(s.inner[20:])
	if s.HasExtraFields() {
		end := unpackNumber(s.inner[24:])
		ret = OutPointFromSliceUnchecked(s.inner[start:end])
	} else {
		ret = OutPointFromSliceUnchecked(s.inner[start:])
	}
	return ret
}

func (s *DasLockOutPointTableV1) AsBuilder() DasLockOutPointTableV1Builder {
	ret := NewDasLockOutPointTableV1Builder().CkbSignall(*s.CkbSignall()).CkbMultisign(*s.CkbMultisign()).CkbAnyoneCanPay(*s.CkbAnyoneCanPay()).Eth(*s.Eth()).Tron(*s.Tron())
	return *ret
}

type ConfigCellMainV2Builder struct {
	status                   Uint8
	type_id_table            TypeIdTableV2
	das_lock_out_point_table DasLockOutPointTableV1
}

func (s *ConfigCellMainV2Builder) Build() ConfigCellMainV2 {
	b := new(bytes.Buffer)

	totalSize := HeaderSizeUint * (3 + 1)
	offsets := make([]uint32, 0, 3)

	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.status.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.type_id_table.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.das_lock_out_point_table.AsSlice()))

	b.Write(packNumber(Number(totalSize)))

	for i := 0; i < len(offsets); i++ {
		b.Write(packNumber(Number(offsets[i])))
	}

	b.Write(s.status.AsSlice())
	b.Write(s.type_id_table.AsSlice())
	b.Write(s.das_lock_out_point_table.AsSlice())
	return ConfigCellMainV2{inner: b.Bytes()}
}

func (s *ConfigCellMainV2Builder) Status(v Uint8) *ConfigCellMainV2Builder {
	s.status = v
	return s
}

func (s *ConfigCellMainV2Builder) TypeIdTable(v TypeIdTableV2) *ConfigCellMainV2Builder {
	s.type_id_table = v
	return s
}

func (s *ConfigCellMainV2Builder) DasLockOutPointTable(v DasLockOutPointTableV1) *ConfigCellMainV2Builder {
	s.das_lock_out_point_table = v
	return s
}

func NewConfigCellMainV2Builder() *ConfigCellMainV2Builder {
	return &ConfigCellMainV2Builder{status: Uint8Default(), type_id_table: TypeIdTableV2Default(), das_lock_out_point_table: DasLockOutPointTableV1Default()}
}

type ConfigCellMainV2 struct {
	inner []byte
}

func ConfigCellMainV2FromSliceUnchecked(slice []byte) *ConfigCellMainV2 {
	return &ConfigCellMainV2{inner: slice}
}
func (s *ConfigCellMainV2) AsSlice() []byte {
	return s.inner
}

func ConfigCellMainV2Default() ConfigCellMainV2 {
	return *ConfigCellMainV2FromSliceUnchecked([]byte{185, 1, 0, 0, 16, 0, 0, 0, 17, 0, 0, 0, 237, 0, 0, 0, 0, 220, 0, 0, 0, 28, 0, 0, 0, 60, 0, 0, 0, 92, 0, 0, 0, 124, 0, 0, 0, 156, 0, 0, 0, 188, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 204, 0, 0, 0, 24, 0, 0, 0, 60, 0, 0, 0, 96, 0, 0, 0, 132, 0, 0, 0, 168, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0})
}

func ConfigCellMainV2FromSlice(slice []byte, compatible bool) (*ConfigCellMainV2, error) {
	sliceLen := len(slice)
	if uint32(sliceLen) < HeaderSizeUint {
		errMsg := strings.Join([]string{"HeaderIsBroken", "ConfigCellMainV2", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}

	totalSize := unpackNumber(slice)
	if Number(sliceLen) != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "ConfigCellMainV2", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}

	if uint32(sliceLen) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "ConfigCellMainV2", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	offsetFirst := unpackNumber(slice[HeaderSizeUint:])
	if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"OffsetsNotMatch", "ConfigCellMainV2", strconv.Itoa(int(offsetFirst % 4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	if sliceLen < int(offsetFirst) {
		errMsg := strings.Join([]string{"HeaderIsBroken", "ConfigCellMainV2", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
		return nil, errors.New(errMsg)
	}

	fieldCount := uint32(offsetFirst)/HeaderSizeUint - 1
	if fieldCount < 3 {
		return nil, errors.New("FieldCountNotMatch")
	} else if !compatible && fieldCount > 3 {
		return nil, errors.New("FieldCountNotMatch")
	}

	offsets := make([]uint32, fieldCount)

	for i := 0; i < int(fieldCount); i++ {
		offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
	}
	offsets = append(offsets, uint32(totalSize))

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 && offsets[i-1] > offsets[i] {
			return nil, errors.New("OffsetsNotMatch")
		}
	}

	var err error

	_, err = Uint8FromSlice(slice[offsets[0]:offsets[1]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = TypeIdTableV2FromSlice(slice[offsets[1]:offsets[2]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = DasLockOutPointTableV1FromSlice(slice[offsets[2]:offsets[3]], compatible)
	if err != nil {
		return nil, err
	}

	return &ConfigCellMainV2{inner: slice}, nil
}

func (s *ConfigCellMainV2) TotalSize() uint {
	return uint(unpackNumber(s.inner))
}
func (s *ConfigCellMainV2) FieldCount() uint {
	var number uint = 0
	if uint32(s.TotalSize()) == HeaderSizeUint {
		return number
	}
	number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
	return number
}
func (s *ConfigCellMainV2) Len() uint {
	return s.FieldCount()
}
func (s *ConfigCellMainV2) IsEmpty() bool {
	return s.Len() == 0
}
func (s *ConfigCellMainV2) CountExtraFields() uint {
	return s.FieldCount() - 3
}

func (s *ConfigCellMainV2) HasExtraFields() bool {
	return 3 != s.FieldCount()
}

func (s *ConfigCellMainV2) Status() *Uint8 {
	start := unpackNumber(s.inner[4:])
	end := unpackNumber(s.inner[8:])
	return Uint8FromSliceUnchecked(s.inner[start:end])
}

func (s *ConfigCellMainV2) TypeIdTable() *TypeIdTableV2 {
	start := unpackNumber(s.inner[8:])
	end := unpackNumber(s.inner[12:])
	return TypeIdTableV2FromSliceUnchecked(s.inner[start:end])
}

func (s *ConfigCellMainV2) DasLockOutPointTable() *DasLockOutPointTableV1 {
	var ret *DasLockOutPointTableV1
	start := unpackNumber(s.inner[12:])
	if s.HasExtraFields() {
		end := unpackNumber(s.inner[16:])
		ret = DasLockOutPointTableV1FromSliceUnchecked(s.inner[start:end])
	} else {
		ret = DasLockOutPointTableV1FromSliceUnchecked(s.inner[start:])
	}
	return ret
}

func (s *ConfigCellMainV2) AsBuilder() ConfigCellMainV2Builder {
	ret := NewConfigCellMainV2Builder().Status(*s.Status()).TypeIdTable(*s.TypeIdTable()).DasLockOutPointTable(*s.DasLockOutPointTable())
	return *ret
}

type TypeIdTableV2Builder struct {
	account_cell        Hash
	apply_register_cell Hash
	balance_cell        Hash
	income_cell         Hash
	pre_account_cell    Hash
	proposal_cell       Hash
}

func (s *TypeIdTableV2Builder) Build() TypeIdTableV2 {
	b := new(bytes.Buffer)

	totalSize := HeaderSizeUint * (6 + 1)
	offsets := make([]uint32, 0, 6)

	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.account_cell.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.apply_register_cell.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.balance_cell.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.income_cell.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.pre_account_cell.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.proposal_cell.AsSlice()))

	b.Write(packNumber(Number(totalSize)))

	for i := 0; i < len(offsets); i++ {
		b.Write(packNumber(Number(offsets[i])))
	}

	b.Write(s.account_cell.AsSlice())
	b.Write(s.apply_register_cell.AsSlice())
	b.Write(s.balance_cell.AsSlice())
	b.Write(s.income_cell.AsSlice())
	b.Write(s.pre_account_cell.AsSlice())
	b.Write(s.proposal_cell.AsSlice())
	return TypeIdTableV2{inner: b.Bytes()}
}

func (s *TypeIdTableV2Builder) AccountCell(v Hash) *TypeIdTableV2Builder {
	s.account_cell = v
	return s
}

func (s *TypeIdTableV2Builder) ApplyRegisterCell(v Hash) *TypeIdTableV2Builder {
	s.apply_register_cell = v
	return s
}

func (s *TypeIdTableV2Builder) BalanceCell(v Hash) *TypeIdTableV2Builder {
	s.balance_cell = v
	return s
}

func (s *TypeIdTableV2Builder) IncomeCell(v Hash) *TypeIdTableV2Builder {
	s.income_cell = v
	return s
}

func (s *TypeIdTableV2Builder) PreAccountCell(v Hash) *TypeIdTableV2Builder {
	s.pre_account_cell = v
	return s
}

func (s *TypeIdTableV2Builder) ProposalCell(v Hash) *TypeIdTableV2Builder {
	s.proposal_cell = v
	return s
}

func NewTypeIdTableV2Builder() *TypeIdTableV2Builder {
	return &TypeIdTableV2Builder{account_cell: HashDefault(), apply_register_cell: HashDefault(), balance_cell: HashDefault(), income_cell: HashDefault(), pre_account_cell: HashDefault(), proposal_cell: HashDefault()}
}

type TypeIdTableV2 struct {
	inner []byte
}

func TypeIdTableV2FromSliceUnchecked(slice []byte) *TypeIdTableV2 {
	return &TypeIdTableV2{inner: slice}
}
func (s *TypeIdTableV2) AsSlice() []byte {
	return s.inner
}

func TypeIdTableV2Default() TypeIdTableV2 {
	return *TypeIdTableV2FromSliceUnchecked([]byte{220, 0, 0, 0, 28, 0, 0, 0, 60, 0, 0, 0, 92, 0, 0, 0, 124, 0, 0, 0, 156, 0, 0, 0, 188, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0})
}

func TypeIdTableV2FromSlice(slice []byte, compatible bool) (*TypeIdTableV2, error) {
	sliceLen := len(slice)
	if uint32(sliceLen) < HeaderSizeUint {
		errMsg := strings.Join([]string{"HeaderIsBroken", "TypeIdTableV2", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}

	totalSize := unpackNumber(slice)
	if Number(sliceLen) != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "TypeIdTableV2", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}

	if uint32(sliceLen) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "TypeIdTableV2", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	offsetFirst := unpackNumber(slice[HeaderSizeUint:])
	if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"OffsetsNotMatch", "TypeIdTableV2", strconv.Itoa(int(offsetFirst % 4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	if sliceLen < int(offsetFirst) {
		errMsg := strings.Join([]string{"HeaderIsBroken", "TypeIdTableV2", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
		return nil, errors.New(errMsg)
	}

	fieldCount := uint32(offsetFirst)/HeaderSizeUint - 1
	if fieldCount < 6 {
		return nil, errors.New("FieldCountNotMatch")
	} else if !compatible && fieldCount > 6 {
		return nil, errors.New("FieldCountNotMatch")
	}

	offsets := make([]uint32, fieldCount)

	for i := 0; i < int(fieldCount); i++ {
		offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
	}
	offsets = append(offsets, uint32(totalSize))

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 && offsets[i-1] > offsets[i] {
			return nil, errors.New("OffsetsNotMatch")
		}
	}

	var err error

	_, err = HashFromSlice(slice[offsets[0]:offsets[1]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = HashFromSlice(slice[offsets[1]:offsets[2]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = HashFromSlice(slice[offsets[2]:offsets[3]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = HashFromSlice(slice[offsets[3]:offsets[4]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = HashFromSlice(slice[offsets[4]:offsets[5]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = HashFromSlice(slice[offsets[5]:offsets[6]], compatible)
	if err != nil {
		return nil, err
	}

	return &TypeIdTableV2{inner: slice}, nil
}

func (s *TypeIdTableV2) TotalSize() uint {
	return uint(unpackNumber(s.inner))
}
func (s *TypeIdTableV2) FieldCount() uint {
	var number uint = 0
	if uint32(s.TotalSize()) == HeaderSizeUint {
		return number
	}
	number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
	return number
}
func (s *TypeIdTableV2) Len() uint {
	return s.FieldCount()
}
func (s *TypeIdTableV2) IsEmpty() bool {
	return s.Len() == 0
}
func (s *TypeIdTableV2) CountExtraFields() uint {
	return s.FieldCount() - 6
}

func (s *TypeIdTableV2) HasExtraFields() bool {
	return 6 != s.FieldCount()
}

func (s *TypeIdTableV2) AccountCell() *Hash {
	start := unpackNumber(s.inner[4:])
	end := unpackNumber(s.inner[8:])
	return HashFromSliceUnchecked(s.inner[start:end])
}

func (s *TypeIdTableV2) ApplyRegisterCell() *Hash {
	start := unpackNumber(s.inner[8:])
	end := unpackNumber(s.inner[12:])
	return HashFromSliceUnchecked(s.inner[start:end])
}

func (s *TypeIdTableV2) BalanceCell() *Hash {
	start := unpackNumber(s.inner[12:])
	end := unpackNumber(s.inner[16:])
	return HashFromSliceUnchecked(s.inner[start:end])
}

func (s *TypeIdTableV2) IncomeCell() *Hash {
	start := unpackNumber(s.inner[16:])
	end := unpackNumber(s.inner[20:])
	return HashFromSliceUnchecked(s.inner[start:end])
}

func (s *TypeIdTableV2) PreAccountCell() *Hash {
	start := unpackNumber(s.inner[20:])
	end := unpackNumber(s.inner[24:])
	return HashFromSliceUnchecked(s.inner[start:end])
}

func (s *TypeIdTableV2) ProposalCell() *Hash {
	var ret *Hash
	start := unpackNumber(s.inner[24:])
	if s.HasExtraFields() {
		end := unpackNumber(s.inner[28:])
		ret = HashFromSliceUnchecked(s.inner[start:end])
	} else {
		ret = HashFromSliceUnchecked(s.inner[start:])
	}
	return ret
}

func (s *TypeIdTableV2) AsBuilder() TypeIdTableV2Builder {
	ret := NewTypeIdTableV2Builder().AccountCell(*s.AccountCell()).ApplyRegisterCell(*s.ApplyRegisterCell()).BalanceCell(*s.BalanceCell()).IncomeCell(*s.IncomeCell()).PreAccountCell(*s.PreAccountCell()).ProposalCell(*s.ProposalCell())
	return *ret
}

type ConfigCellMainV3Builder struct {
	status                   Uint8
	type_id_table            TypeIdTableV3
	das_lock_out_point_table DasLockOutPointTableV1
}

func (s *ConfigCellMainV3Builder) Build() ConfigCellMainV3 {
	b := new(bytes.Buffer)

	totalSize := HeaderSizeUint * (3 + 1)
	offsets := make([]uint32, 0, 3)

	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.status.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.type_id_table.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.das_lock_out_point_table.AsSlice()))

	b.Write(packNumber(Number(totalSize)))

	for i := 0; i < len(offsets); i++ {
		b.Write(packNumber(Number(offsets[i])))
	}

	b.Write(s.status.AsSlice())
	b.Write(s.type_id_table.AsSlice())
	b.Write(s.das_lock_out_point_table.AsSlice())
	return ConfigCellMainV3{inner: b.Bytes()}
}

func (s *ConfigCellMainV3Builder) Status(v Uint8) *ConfigCellMainV3Builder {
	s.status = v
	return s
}

func (s *ConfigCellMainV3Builder) TypeIdTable(v TypeIdTableV3) *ConfigCellMainV3Builder {
	s.type_id_table = v
	return s
}

func (s *ConfigCellMainV3Builder) DasLockOutPointTable(v DasLockOutPointTableV1) *ConfigCellMainV3Builder {
	s.das_lock_out_point_table = v
	return s
}

func NewConfigCellMainV3Builder() *ConfigCellMainV3Builder {
	return &ConfigCellMainV3Builder{status: Uint8Default(), type_id_table: TypeIdTableV3Default(), das_lock_out_point_table: DasLockOutPointTableV1Default()}
}

type ConfigCellMainV3 struct {
	inner []byte
}

func ConfigCellMainV3FromSliceUnchecked(slice []byte) *ConfigCellMainV3 {
	return &ConfigCellMainV3{inner: slice}
}
func (s *ConfigCellMainV3) AsSlice() []byte {
	return s.inner
}

func ConfigCellMainV3Default() ConfigCellMainV3 {
	return *ConfigCellMainV3FromSliceUnchecked([]byte{1, 2, 0, 0, 16, 0, 0, 0, 17, 0, 0, 0, 53, 1, 0, 0, 0, 36, 1, 0, 0, 36, 0, 0, 0, 68, 0, 0, 0, 100, 0, 0, 0, 132, 0, 0, 0, 164, 0, 0, 0, 196, 0, 0, 0, 228, 0, 0, 0, 4, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 204, 0, 0, 0, 24, 0, 0, 0, 60, 0, 0, 0, 96, 0, 0, 0, 132, 0, 0, 0, 168, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0})
}

func ConfigCellMainV3FromSlice(slice []byte, compatible bool) (*ConfigCellMainV3, error) {
	sliceLen := len(slice)
	if uint32(sliceLen) < HeaderSizeUint {
		errMsg := strings.Join([]string{"HeaderIsBroken", "ConfigCellMainV3", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}

	totalSize := unpackNumber(slice)
	if Number(sliceLen) != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "ConfigCellMainV3", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}

	if uint32(sliceLen) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "ConfigCellMainV3", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	offsetFirst := unpackNumber(slice[HeaderSizeUint:])
	if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"OffsetsNotMatch", "ConfigCellMainV3", strconv.Itoa(int(offsetFirst % 4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	if sliceLen < int(offsetFirst) {
		errMsg := strings.Join([]string{"HeaderIsBroken", "ConfigCellMainV3", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
		return nil, errors.New(errMsg)
	}

	fieldCount := uint32(offsetFirst)/HeaderSizeUint - 1
	if fieldCount < 3 {
		return nil, errors.New("FieldCountNotMatch")
	} else if !compatible && fieldCount > 3 {
		return nil, errors.New("FieldCountNotMatch")
	}

	offsets := make([]uint32, fieldCount)

	for i := 0; i < int(fieldCount); i++ {
		offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
	}
	offsets = append(offsets, uint32(totalSize))

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 && offsets[i-1] > offsets[i] {
			return nil, errors.New("OffsetsNotMatch")
		}
	}

	var err error

	_, err = Uint8FromSlice(slice[offsets[0]:offsets[1]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = TypeIdTableV3FromSlice(slice[offsets[1]:offsets[2]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = DasLockOutPointTableV1FromSlice(slice[offsets[2]:offsets[3]], compatible)
	if err != nil {
		return nil, err
	}

	return &ConfigCellMainV3{inner: slice}, nil
}

func (s *ConfigCellMainV3) TotalSize() uint {
	return uint(unpackNumber(s.inner))
}
func (s *ConfigCellMainV3) FieldCount() uint {
	var number uint = 0
	if uint32(s.TotalSize()) == HeaderSizeUint {
		return number
	}
	number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
	return number
}
func (s *ConfigCellMainV3) Len() uint {
	return s.FieldCount()
}
func (s *ConfigCellMainV3) IsEmpty() bool {
	return s.Len() == 0
}
func (s *ConfigCellMainV3) CountExtraFields() uint {
	return s.FieldCount() - 3
}

func (s *ConfigCellMainV3) HasExtraFields() bool {
	return 3 != s.FieldCount()
}

func (s *ConfigCellMainV3) Status() *Uint8 {
	start := unpackNumber(s.inner[4:])
	end := unpackNumber(s.inner[8:])
	return Uint8FromSliceUnchecked(s.inner[start:end])
}

func (s *ConfigCellMainV3) TypeIdTable() *TypeIdTableV3 {
	start := unpackNumber(s.inner[8:])
	end := unpackNumber(s.inner[12:])
	return TypeIdTableV3FromSliceUnchecked(s.inner[start:end])
}

func (s *ConfigCellMainV3) DasLockOutPointTable() *DasLockOutPointTableV1 {
	var ret *DasLockOutPointTableV1
	start := unpackNumber(s.inner[12:])
	if s.HasExtraFields() {
		end := unpackNumber(s.inner[16:])
		ret = DasLockOutPointTableV1FromSliceUnchecked(s.inner[start:end])
	} else {
		ret = DasLockOutPointTableV1FromSliceUnchecked(s.inner[start:])
	}
	return ret
}

func (s *ConfigCellMainV3) AsBuilder() ConfigCellMainV3Builder {
	ret := NewConfigCellMainV3Builder().Status(*s.Status()).TypeIdTable(*s.TypeIdTable()).DasLockOutPointTable(*s.DasLockOutPointTable())
	return *ret
}

type TypeIdTableV3Builder struct {
	account_cell         Hash
	apply_register_cell  Hash
	balance_cell         Hash
	income_cell          Hash
	pre_account_cell     Hash
	proposal_cell        Hash
	account_sale_cell    Hash
	account_auction_cell Hash
}

func (s *TypeIdTableV3Builder) Build() TypeIdTableV3 {
	b := new(bytes.Buffer)

	totalSize := HeaderSizeUint * (8 + 1)
	offsets := make([]uint32, 0, 8)

	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.account_cell.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.apply_register_cell.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.balance_cell.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.income_cell.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.pre_account_cell.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.proposal_cell.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.account_sale_cell.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.account_auction_cell.AsSlice()))

	b.Write(packNumber(Number(totalSize)))

	for i := 0; i < len(offsets); i++ {
		b.Write(packNumber(Number(offsets[i])))
	}

	b.Write(s.account_cell.AsSlice())
	b.Write(s.apply_register_cell.AsSlice())
	b.Write(s.balance_cell.AsSlice())
	b.Write(s.income_cell.AsSlice())
	b.Write(s.pre_account_cell.AsSlice())
	b.Write(s.proposal_cell.AsSlice())
	b.Write(s.account_sale_cell.AsSlice())
	b.Write(s.account_auction_cell.AsSlice())
	return TypeIdTableV3{inner: b.Bytes()}
}

func (s *TypeIdTableV3Builder) AccountCell(v Hash) *TypeIdTableV3Builder {
	s.account_cell = v
	return s
}

func (s *TypeIdTableV3Builder) ApplyRegisterCell(v Hash) *TypeIdTableV3Builder {
	s.apply_register_cell = v
	return s
}

func (s *TypeIdTableV3Builder) BalanceCell(v Hash) *TypeIdTableV3Builder {
	s.balance_cell = v
	return s
}

func (s *TypeIdTableV3Builder) IncomeCell(v Hash) *TypeIdTableV3Builder {
	s.income_cell = v
	return s
}

func (s *TypeIdTableV3Builder) PreAccountCell(v Hash) *TypeIdTableV3Builder {
	s.pre_account_cell = v
	return s
}

func (s *TypeIdTableV3Builder) ProposalCell(v Hash) *TypeIdTableV3Builder {
	s.proposal_cell = v
	return s
}

func (s *TypeIdTableV3Builder) AccountSaleCell(v Hash) *TypeIdTableV3Builder {
	s.account_sale_cell = v
	return s
}

func (s *TypeIdTableV3Builder) AccountAuctionCell(v Hash) *TypeIdTableV3Builder {
	s.account_auction_cell = v
	return s
}

func NewTypeIdTableV3Builder() *TypeIdTableV3Builder {
	return &TypeIdTableV3Builder{account_cell: HashDefault(), apply_register_cell: HashDefault(), balance_cell: HashDefault(), income_cell: HashDefault(), pre_account_cell: HashDefault(), proposal_cell: HashDefault(), account_sale_cell: HashDefault(), account_auction_cell: HashDefault()}
}

type TypeIdTableV3 struct {
	inner []byte
}

func TypeIdTableV3FromSliceUnchecked(slice []byte) *TypeIdTableV3 {
	return &TypeIdTableV3{inner: slice}
}
func (s *TypeIdTableV3) AsSlice() []byte {
	return s.inner
}

func TypeIdTableV3Default() TypeIdTableV3 {
	return *TypeIdTableV3FromSliceUnchecked([]byte{36, 1, 0, 0, 36, 0, 0, 0, 68, 0, 0, 0, 100, 0, 0, 0, 132, 0, 0, 0, 164, 0, 0, 0, 196, 0, 0, 0, 228, 0, 0, 0, 4, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0})
}

func TypeIdTableV3FromSlice(slice []byte, compatible bool) (*TypeIdTableV3, error) {
	sliceLen := len(slice)
	if uint32(sliceLen) < HeaderSizeUint {
		errMsg := strings.Join([]string{"HeaderIsBroken", "TypeIdTableV3", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}

	totalSize := unpackNumber(slice)
	if Number(sliceLen) != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "TypeIdTableV3", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}

	if uint32(sliceLen) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "TypeIdTableV3", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	offsetFirst := unpackNumber(slice[HeaderSizeUint:])
	if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"OffsetsNotMatch", "TypeIdTableV3", strconv.Itoa(int(offsetFirst % 4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	if sliceLen < int(offsetFirst) {
		errMsg := strings.Join([]string{"HeaderIsBroken", "TypeIdTableV3", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
		return nil, errors.New(errMsg)
	}

	fieldCount := uint32(offsetFirst)/HeaderSizeUint - 1
	if fieldCount < 8 {
		return nil, errors.New("FieldCountNotMatch")
	} else if !compatible && fieldCount > 8 {
		return nil, errors.New("FieldCountNotMatch")
	}

	offsets := make([]uint32, fieldCount)

	for i := 0; i < int(fieldCount); i++ {
		offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
	}
	offsets = append(offsets, uint32(totalSize))

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 && offsets[i-1] > offsets[i] {
			return nil, errors.New("OffsetsNotMatch")
		}
	}

	var err error

	_, err = HashFromSlice(slice[offsets[0]:offsets[1]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = HashFromSlice(slice[offsets[1]:offsets[2]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = HashFromSlice(slice[offsets[2]:offsets[3]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = HashFromSlice(slice[offsets[3]:offsets[4]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = HashFromSlice(slice[offsets[4]:offsets[5]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = HashFromSlice(slice[offsets[5]:offsets[6]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = HashFromSlice(slice[offsets[6]:offsets[7]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = HashFromSlice(slice[offsets[7]:offsets[8]], compatible)
	if err != nil {
		return nil, err
	}

	return &TypeIdTableV3{inner: slice}, nil
}

func (s *TypeIdTableV3) TotalSize() uint {
	return uint(unpackNumber(s.inner))
}
func (s *TypeIdTableV3) FieldCount() uint {
	var number uint = 0
	if uint32(s.TotalSize()) == HeaderSizeUint {
		return number
	}
	number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
	return number
}
func (s *TypeIdTableV3) Len() uint {
	return s.FieldCount()
}
func (s *TypeIdTableV3) IsEmpty() bool {
	return s.Len() == 0
}
func (s *TypeIdTableV3) CountExtraFields() uint {
	return s.FieldCount() - 8
}

func (s *TypeIdTableV3) HasExtraFields() bool {
	return 8 != s.FieldCount()
}

func (s *TypeIdTableV3) AccountCell() *Hash {
	start := unpackNumber(s.inner[4:])
	end := unpackNumber(s.inner[8:])
	return HashFromSliceUnchecked(s.inner[start:end])
}

func (s *TypeIdTableV3) ApplyRegisterCell() *Hash {
	start := unpackNumber(s.inner[8:])
	end := unpackNumber(s.inner[12:])
	return HashFromSliceUnchecked(s.inner[start:end])
}

func (s *TypeIdTableV3) BalanceCell() *Hash {
	start := unpackNumber(s.inner[12:])
	end := unpackNumber(s.inner[16:])
	return HashFromSliceUnchecked(s.inner[start:end])
}

func (s *TypeIdTableV3) IncomeCell() *Hash {
	start := unpackNumber(s.inner[16:])
	end := unpackNumber(s.inner[20:])
	return HashFromSliceUnchecked(s.inner[start:end])
}

func (s *TypeIdTableV3) PreAccountCell() *Hash {
	start := unpackNumber(s.inner[20:])
	end := unpackNumber(s.inner[24:])
	return HashFromSliceUnchecked(s.inner[start:end])
}

func (s *TypeIdTableV3) ProposalCell() *Hash {
	start := unpackNumber(s.inner[24:])
	end := unpackNumber(s.inner[28:])
	return HashFromSliceUnchecked(s.inner[start:end])
}

func (s *TypeIdTableV3) AccountSaleCell() *Hash {
	start := unpackNumber(s.inner[28:])
	end := unpackNumber(s.inner[32:])
	return HashFromSliceUnchecked(s.inner[start:end])
}

func (s *TypeIdTableV3) AccountAuctionCell() *Hash {
	var ret *Hash
	start := unpackNumber(s.inner[32:])
	if s.HasExtraFields() {
		end := unpackNumber(s.inner[36:])
		ret = HashFromSliceUnchecked(s.inner[start:end])
	} else {
		ret = HashFromSliceUnchecked(s.inner[start:])
	}
	return ret
}

func (s *TypeIdTableV3) AsBuilder() TypeIdTableV3Builder {
	ret := NewTypeIdTableV3Builder().AccountCell(*s.AccountCell()).ApplyRegisterCell(*s.ApplyRegisterCell()).BalanceCell(*s.BalanceCell()).IncomeCell(*s.IncomeCell()).PreAccountCell(*s.PreAccountCell()).ProposalCell(*s.ProposalCell()).AccountSaleCell(*s.AccountSaleCell()).AccountAuctionCell(*s.AccountAuctionCell())
	return *ret
}

type ConfigCellMainV4Builder struct {
	status                   Uint8
	type_id_table            TypeIdTableV4
	das_lock_out_point_table DasLockOutPointTableV1
}

func (s *ConfigCellMainV4Builder) Build() ConfigCellMainV4 {
	b := new(bytes.Buffer)

	totalSize := HeaderSizeUint * (3 + 1)
	offsets := make([]uint32, 0, 3)

	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.status.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.type_id_table.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.das_lock_out_point_table.AsSlice()))

	b.Write(packNumber(Number(totalSize)))

	for i := 0; i < len(offsets); i++ {
		b.Write(packNumber(Number(offsets[i])))
	}

	b.Write(s.status.AsSlice())
	b.Write(s.type_id_table.AsSlice())
	b.Write(s.das_lock_out_point_table.AsSlice())
	return ConfigCellMainV4{inner: b.Bytes()}
}

func (s *ConfigCellMainV4Builder) Status(v Uint8) *ConfigCellMainV4Builder {
	s.status = v
	return s
}

func (s *ConfigCellMainV4Builder) TypeIdTable(v TypeIdTableV4) *ConfigCellMainV4Builder {
	s.type_id_table = v
	return s
}

func (s *ConfigCellMainV4Builder) DasLockOutPointTable(v DasLockOutPointTableV1) *ConfigCellMainV4Builder {
	s.das_lock_out_point_table = v
	return s
}

func NewConfigCellMainV4Builder() *ConfigCellMainV4Builder {
	return &ConfigCellMainV4Builder{status: Uint8Default(), type_id_table: TypeIdTableV4Default(), das_lock_out_point_table: DasLockOutPointTableV1Default()}
}

type ConfigCellMainV4 struct {
	inner []byte
}

func ConfigCellMainV4FromSliceUnchecked(slice []byte) *ConfigCellMainV4 {
	return &ConfigCellMainV4{inner: slice}
}
func (s *ConfigCellMainV4) AsSlice() []byte {
	return s.inner
}

func ConfigCellMainV4Default() ConfigCellMainV4 {
	return *ConfigCellMainV4FromSliceUnchecked([]byte{73, 2, 0, 0, 16, 0, 0, 0, 17, 0, 0, 0, 125, 1, 0, 0, 0, 108, 1, 0, 0, 44, 0, 0, 0, 76, 0, 0, 0, 108, 0, 0, 0, 140, 0, 0, 0, 172, 0, 0, 0, 204, 0, 0, 0, 236, 0, 0, 0, 12, 1, 0, 0, 44, 1, 0, 0, 76, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 204, 0, 0, 0, 24, 0, 0, 0, 60, 0, 0, 0, 96, 0, 0, 0, 132, 0, 0, 0, 168, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0})
}

func ConfigCellMainV4FromSlice(slice []byte, compatible bool) (*ConfigCellMainV4, error) {
	sliceLen := len(slice)
	if uint32(sliceLen) < HeaderSizeUint {
		errMsg := strings.Join([]string{"HeaderIsBroken", "ConfigCellMainV4", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}

	totalSize := unpackNumber(slice)
	if Number(sliceLen) != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "ConfigCellMainV4", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}

	if uint32(sliceLen) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "ConfigCellMainV4", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	offsetFirst := unpackNumber(slice[HeaderSizeUint:])
	if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"OffsetsNotMatch", "ConfigCellMainV4", strconv.Itoa(int(offsetFirst % 4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	if sliceLen < int(offsetFirst) {
		errMsg := strings.Join([]string{"HeaderIsBroken", "ConfigCellMainV4", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
		return nil, errors.New(errMsg)
	}

	fieldCount := uint32(offsetFirst)/HeaderSizeUint - 1
	if fieldCount < 3 {
		return nil, errors.New("FieldCountNotMatch")
	} else if !compatible && fieldCount > 3 {
		return nil, errors.New("FieldCountNotMatch")
	}

	offsets := make([]uint32, fieldCount)

	for i := 0; i < int(fieldCount); i++ {
		offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
	}
	offsets = append(offsets, uint32(totalSize))

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 && offsets[i-1] > offsets[i] {
			return nil, errors.New("OffsetsNotMatch")
		}
	}

	var err error

	_, err = Uint8FromSlice(slice[offsets[0]:offsets[1]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = TypeIdTableV4FromSlice(slice[offsets[1]:offsets[2]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = DasLockOutPointTableV1FromSlice(slice[offsets[2]:offsets[3]], compatible)
	if err != nil {
		return nil, err
	}

	return &ConfigCellMainV4{inner: slice}, nil
}

func (s *ConfigCellMainV4) TotalSize() uint {
	return uint(unpackNumber(s.inner))
}
func (s *ConfigCellMainV4) FieldCount() uint {
	var number uint = 0
	if uint32(s.TotalSize()) == HeaderSizeUint {
		return number
	}
	number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
	return number
}
func (s *ConfigCellMainV4) Len() uint {
	return s.FieldCount()
}
func (s *ConfigCellMainV4) IsEmpty() bool {
	return s.Len() == 0
}
func (s *ConfigCellMainV4) CountExtraFields() uint {
	return s.FieldCount() - 3
}

func (s *ConfigCellMainV4) HasExtraFields() bool {
	return 3 != s.FieldCount()
}

func (s *ConfigCellMainV4) Status() *Uint8 {
	start := unpackNumber(s.inner[4:])
	end := unpackNumber(s.inner[8:])
	return Uint8FromSliceUnchecked(s.inner[start:end])
}

func (s *ConfigCellMainV4) TypeIdTable() *TypeIdTableV4 {
	start := unpackNumber(s.inner[8:])
	end := unpackNumber(s.inner[12:])
	return TypeIdTableV4FromSliceUnchecked(s.inner[start:end])
}

func (s *ConfigCellMainV4) DasLockOutPointTable() *DasLockOutPointTableV1 {
	var ret *DasLockOutPointTableV1
	start := unpackNumber(s.inner[12:])
	if s.HasExtraFields() {
		end := unpackNumber(s.inner[16:])
		ret = DasLockOutPointTableV1FromSliceUnchecked(s.inner[start:end])
	} else {
		ret = DasLockOutPointTableV1FromSliceUnchecked(s.inner[start:])
	}
	return ret
}

func (s *ConfigCellMainV4) AsBuilder() ConfigCellMainV4Builder {
	ret := NewConfigCellMainV4Builder().Status(*s.Status()).TypeIdTable(*s.TypeIdTable()).DasLockOutPointTable(*s.DasLockOutPointTable())
	return *ret
}

type ConfigCellMainV5Builder struct {
	status                   Uint8
	type_id_table            TypeIdTableV4
	das_lock_out_point_table DasLockOutPointTable
}

func (s *ConfigCellMainV5Builder) Build() ConfigCellMainV5 {
	b := new(bytes.Buffer)

	totalSize := HeaderSizeUint * (3 + 1)
	offsets := make([]uint32, 0, 3)

	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.status.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.type_id_table.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.das_lock_out_point_table.AsSlice()))

	b.Write(packNumber(Number(totalSize)))

	for i := 0; i < len(offsets); i++ {
		b.Write(packNumber(Number(offsets[i])))
	}

	b.Write(s.status.AsSlice())
	b.Write(s.type_id_table.AsSlice())
	b.Write(s.das_lock_out_point_table.AsSlice())
	return ConfigCellMainV5{inner: b.Bytes()}
}

func (s *ConfigCellMainV5Builder) Status(v Uint8) *ConfigCellMainV5Builder {
	s.status = v
	return s
}

func (s *ConfigCellMainV5Builder) TypeIdTable(v TypeIdTableV4) *ConfigCellMainV5Builder {
	s.type_id_table = v
	return s
}

func (s *ConfigCellMainV5Builder) DasLockOutPointTable(v DasLockOutPointTable) *ConfigCellMainV5Builder {
	s.das_lock_out_point_table = v
	return s
}

func NewConfigCellMainV5Builder() *ConfigCellMainV5Builder {
	return &ConfigCellMainV5Builder{status: Uint8Default(), type_id_table: TypeIdTableV4Default(), das_lock_out_point_table: DasLockOutPointTableDefault()}
}

type ConfigCellMainV5 struct {
	inner []byte
}

func ConfigCellMainV5FromSliceUnchecked(slice []byte) *ConfigCellMainV5 {
	return &ConfigCellMainV5{inner: slice}
}
func (s *ConfigCellMainV5) AsSlice() []byte {
	return s.inner
}

func ConfigCellMainV5Default() ConfigCellMainV5 {
	return *ConfigCellMainV5FromSliceUnchecked([]byte{113, 2, 0, 0, 16, 0, 0, 0, 17, 0, 0, 0, 125, 1, 0, 0, 0, 108, 1, 0, 0, 44, 0, 0, 0, 76, 0, 0, 0, 108, 0, 0, 0, 140, 0, 0, 0, 172, 0, 0, 0, 204, 0, 0, 0, 236, 0, 0, 0, 12, 1, 0, 0, 44, 1, 0, 0, 76, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 244, 0, 0, 0, 28, 0, 0, 0, 64, 0, 0, 0, 100, 0, 0, 0, 136, 0, 0, 0, 172, 0, 0, 0, 208, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0})
}

func ConfigCellMainV5FromSlice(slice []byte, compatible bool) (*ConfigCellMainV5, error) {
	sliceLen := len(slice)
	if uint32(sliceLen) < HeaderSizeUint {
		errMsg := strings.Join([]string{"HeaderIsBroken", "ConfigCellMainV5", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}

	totalSize := unpackNumber(slice)
	if Number(sliceLen) != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "ConfigCellMainV5", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}

	if uint32(sliceLen) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "ConfigCellMainV5", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	offsetFirst := unpackNumber(slice[HeaderSizeUint:])
	if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"OffsetsNotMatch", "ConfigCellMainV5", strconv.Itoa(int(offsetFirst % 4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	if sliceLen < int(offsetFirst) {
		errMsg := strings.Join([]string{"HeaderIsBroken", "ConfigCellMainV5", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
		return nil, errors.New(errMsg)
	}

	fieldCount := uint32(offsetFirst)/HeaderSizeUint - 1
	if fieldCount < 3 {
		return nil, errors.New("FieldCountNotMatch")
	} else if !compatible && fieldCount > 3 {
		return nil, errors.New("FieldCountNotMatch")
	}

	offsets := make([]uint32, fieldCount)

	for i := 0; i < int(fieldCount); i++ {
		offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
	}
	offsets = append(offsets, uint32(totalSize))

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 && offsets[i-1] > offsets[i] {
			return nil, errors.New("OffsetsNotMatch")
		}
	}

	var err error

	_, err = Uint8FromSlice(slice[offsets[0]:offsets[1]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = TypeIdTableV4FromSlice(slice[offsets[1]:offsets[2]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = DasLockOutPointTableFromSlice(slice[offsets[2]:offsets[3]], compatible)
	if err != nil {
		return nil, err
	}

	return &ConfigCellMainV5{inner: slice}, nil
}

func (s *ConfigCellMainV5) TotalSize() uint {
	return uint(unpackNumber(s.inner))
}
func (s *ConfigCellMainV5) FieldCount() uint {
	var number uint = 0
	if uint32(s.TotalSize()) == HeaderSizeUint {
		return number
	}
	number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
	return number
}
func (s *ConfigCellMainV5) Len() uint {
	return s.FieldCount()
}
func (s *ConfigCellMainV5) IsEmpty() bool {
	return s.Len() == 0
}
func (s *ConfigCellMainV5) CountExtraFields() uint {
	return s.FieldCount() - 3
}

func (s *ConfigCellMainV5) HasExtraFields() bool {
	return 3 != s.FieldCount()
}

func (s *ConfigCellMainV5) Status() *Uint8 {
	start := unpackNumber(s.inner[4:])
	end := unpackNumber(s.inner[8:])
	return Uint8FromSliceUnchecked(s.inner[start:end])
}

func (s *ConfigCellMainV5) TypeIdTable() *TypeIdTableV4 {
	start := unpackNumber(s.inner[8:])
	end := unpackNumber(s.inner[12:])
	return TypeIdTableV4FromSliceUnchecked(s.inner[start:end])
}

func (s *ConfigCellMainV5) DasLockOutPointTable() *DasLockOutPointTable {
	var ret *DasLockOutPointTable
	start := unpackNumber(s.inner[12:])
	if s.HasExtraFields() {
		end := unpackNumber(s.inner[16:])
		ret = DasLockOutPointTableFromSliceUnchecked(s.inner[start:end])
	} else {
		ret = DasLockOutPointTableFromSliceUnchecked(s.inner[start:])
	}
	return ret
}

func (s *ConfigCellMainV5) AsBuilder() ConfigCellMainV5Builder {
	ret := NewConfigCellMainV5Builder().Status(*s.Status()).TypeIdTable(*s.TypeIdTable()).DasLockOutPointTable(*s.DasLockOutPointTable())
	return *ret
}

type TypeIdTableV4Builder struct {
	account_cell         Hash
	apply_register_cell  Hash
	balance_cell         Hash
	income_cell          Hash
	pre_account_cell     Hash
	proposal_cell        Hash
	account_sale_cell    Hash
	account_auction_cell Hash
	offer_cell           Hash
	reverse_record_cell  Hash
}

func (s *TypeIdTableV4Builder) Build() TypeIdTableV4 {
	b := new(bytes.Buffer)

	totalSize := HeaderSizeUint * (10 + 1)
	offsets := make([]uint32, 0, 10)

	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.account_cell.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.apply_register_cell.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.balance_cell.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.income_cell.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.pre_account_cell.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.proposal_cell.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.account_sale_cell.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.account_auction_cell.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.offer_cell.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.reverse_record_cell.AsSlice()))

	b.Write(packNumber(Number(totalSize)))

	for i := 0; i < len(offsets); i++ {
		b.Write(packNumber(Number(offsets[i])))
	}

	b.Write(s.account_cell.AsSlice())
	b.Write(s.apply_register_cell.AsSlice())
	b.Write(s.balance_cell.AsSlice())
	b.Write(s.income_cell.AsSlice())
	b.Write(s.pre_account_cell.AsSlice())
	b.Write(s.proposal_cell.AsSlice())
	b.Write(s.account_sale_cell.AsSlice())
	b.Write(s.account_auction_cell.AsSlice())
	b.Write(s.offer_cell.AsSlice())
	b.Write(s.reverse_record_cell.AsSlice())
	return TypeIdTableV4{inner: b.Bytes()}
}

func (s *TypeIdTableV4Builder) AccountCell(v Hash) *TypeIdTableV4Builder {
	s.account_cell = v
	return s
}

func (s *TypeIdTableV4Builder) ApplyRegisterCell(v Hash) *TypeIdTableV4Builder {
	s.apply_register_cell = v
	return s
}

func (s *TypeIdTableV4Builder) BalanceCell(v Hash) *TypeIdTableV4Builder {
	s.balance_cell = v
	return s
}

func (s *TypeIdTableV4Builder) IncomeCell(v Hash) *TypeIdTableV4Builder {
	s.income_cell = v
	return s
}

func (s *TypeIdTableV4Builder) PreAccountCell(v Hash) *TypeIdTableV4Builder {
	s.pre_account_cell = v
	return s
}

func (s *TypeIdTableV4Builder) ProposalCell(v Hash) *TypeIdTableV4Builder {
	s.proposal_cell = v
	return s
}

func (s *TypeIdTableV4Builder) AccountSaleCell(v Hash) *TypeIdTableV4Builder {
	s.account_sale_cell = v
	return s
}

func (s *TypeIdTableV4Builder) AccountAuctionCell(v Hash) *TypeIdTableV4Builder {
	s.account_auction_cell = v
	return s
}

func (s *TypeIdTableV4Builder) OfferCell(v Hash) *TypeIdTableV4Builder {
	s.offer_cell = v
	return s
}

func (s *TypeIdTableV4Builder) ReverseRecordCell(v Hash) *TypeIdTableV4Builder {
	s.reverse_record_cell = v
	return s
}

func NewTypeIdTableV4Builder() *TypeIdTableV4Builder {
	return &TypeIdTableV4Builder{account_cell: HashDefault(), apply_register_cell: HashDefault(), balance_cell: HashDefault(), income_cell: HashDefault(), pre_account_cell: HashDefault(), proposal_cell: HashDefault(), account_sale_cell: HashDefault(), account_auction_cell: HashDefault(), offer_cell: HashDefault(), reverse_record_cell: HashDefault()}
}

type TypeIdTableV4 struct {
	inner []byte
}

func TypeIdTableV4FromSliceUnchecked(slice []byte) *TypeIdTableV4 {
	return &TypeIdTableV4{inner: slice}
}
func (s *TypeIdTableV4) AsSlice() []byte {
	return s.inner
}

func TypeIdTableV4Default() TypeIdTableV4 {
	return *TypeIdTableV4FromSliceUnchecked([]byte{108, 1, 0, 0, 44, 0, 0, 0, 76, 0, 0, 0, 108, 0, 0, 0, 140, 0, 0, 0, 172, 0, 0, 0, 204, 0, 0, 0, 236, 0, 0, 0, 12, 1, 0, 0, 44, 1, 0, 0, 76, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0})
}

func TypeIdTableV4FromSlice(slice []byte, compatible bool) (*TypeIdTableV4, error) {
	sliceLen := len(slice)
	if uint32(sliceLen) < HeaderSizeUint {
		errMsg := strings.Join([]string{"HeaderIsBroken", "TypeIdTableV4", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}

	totalSize := unpackNumber(slice)
	if Number(sliceLen) != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "TypeIdTableV4", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}

	if uint32(sliceLen) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "TypeIdTableV4", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	offsetFirst := unpackNumber(slice[HeaderSizeUint:])
	if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"OffsetsNotMatch", "TypeIdTableV4", strconv.Itoa(int(offsetFirst % 4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	if sliceLen < int(offsetFirst) {
		errMsg := strings.Join([]string{"HeaderIsBroken", "TypeIdTableV4", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
		return nil, errors.New(errMsg)
	}

	fieldCount := uint32(offsetFirst)/HeaderSizeUint - 1
	if fieldCount < 10 {
		return nil, errors.New("FieldCountNotMatch")
	} else if !compatible && fieldCount > 10 {
		return nil, errors.New("FieldCountNotMatch")
	}

	offsets := make([]uint32, fieldCount)

	for i := 0; i < int(fieldCount); i++ {
		offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
	}
	offsets = append(offsets, uint32(totalSize))

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 && offsets[i-1] > offsets[i] {
			return nil, errors.New("OffsetsNotMatch")
		}
	}

	var err error

	_, err = HashFromSlice(slice[offsets[0]:offsets[1]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = HashFromSlice(slice[offsets[1]:offsets[2]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = HashFromSlice(slice[offsets[2]:offsets[3]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = HashFromSlice(slice[offsets[3]:offsets[4]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = HashFromSlice(slice[offsets[4]:offsets[5]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = HashFromSlice(slice[offsets[5]:offsets[6]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = HashFromSlice(slice[offsets[6]:offsets[7]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = HashFromSlice(slice[offsets[7]:offsets[8]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = HashFromSlice(slice[offsets[8]:offsets[9]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = HashFromSlice(slice[offsets[9]:offsets[10]], compatible)
	if err != nil {
		return nil, err
	}

	return &TypeIdTableV4{inner: slice}, nil
}

func (s *TypeIdTableV4) TotalSize() uint {
	return uint(unpackNumber(s.inner))
}
func (s *TypeIdTableV4) FieldCount() uint {
	var number uint = 0
	if uint32(s.TotalSize()) == HeaderSizeUint {
		return number
	}
	number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
	return number
}
func (s *TypeIdTableV4) Len() uint {
	return s.FieldCount()
}
func (s *TypeIdTableV4) IsEmpty() bool {
	return s.Len() == 0
}
func (s *TypeIdTableV4) CountExtraFields() uint {
	return s.FieldCount() - 10
}

func (s *TypeIdTableV4) HasExtraFields() bool {
	return 10 != s.FieldCount()
}

func (s *TypeIdTableV4) AccountCell() *Hash {
	start := unpackNumber(s.inner[4:])
	end := unpackNumber(s.inner[8:])
	return HashFromSliceUnchecked(s.inner[start:end])
}

func (s *TypeIdTableV4) ApplyRegisterCell() *Hash {
	start := unpackNumber(s.inner[8:])
	end := unpackNumber(s.inner[12:])
	return HashFromSliceUnchecked(s.inner[start:end])
}

func (s *TypeIdTableV4) BalanceCell() *Hash {
	start := unpackNumber(s.inner[12:])
	end := unpackNumber(s.inner[16:])
	return HashFromSliceUnchecked(s.inner[start:end])
}

func (s *TypeIdTableV4) IncomeCell() *Hash {
	start := unpackNumber(s.inner[16:])
	end := unpackNumber(s.inner[20:])
	return HashFromSliceUnchecked(s.inner[start:end])
}

func (s *TypeIdTableV4) PreAccountCell() *Hash {
	start := unpackNumber(s.inner[20:])
	end := unpackNumber(s.inner[24:])
	return HashFromSliceUnchecked(s.inner[start:end])
}

func (s *TypeIdTableV4) ProposalCell() *Hash {
	start := unpackNumber(s.inner[24:])
	end := unpackNumber(s.inner[28:])
	return HashFromSliceUnchecked(s.inner[start:end])
}

func (s *TypeIdTableV4) AccountSaleCell() *Hash {
	start := unpackNumber(s.inner[28:])
	end := unpackNumber(s.inner[32:])
	return HashFromSliceUnchecked(s.inner[start:end])
}

func (s *TypeIdTableV4) AccountAuctionCell() *Hash {
	start := unpackNumber(s.inner[32:])
	end := unpackNumber(s.inner[36:])
	return HashFromSliceUnchecked(s.inner[start:end])
}

func (s *TypeIdTableV4) OfferCell() *Hash {
	start := unpackNumber(s.inner[36:])
	end := unpackNumber(s.inner[40:])
	return HashFromSliceUnchecked(s.inner[start:end])
}

func (s *TypeIdTableV4) ReverseRecordCell() *Hash {
	var ret *Hash
	start := unpackNumber(s.inner[40:])
	if s.HasExtraFields() {
		end := unpackNumber(s.inner[44:])
		ret = HashFromSliceUnchecked(s.inner[start:end])
	} else {
		ret = HashFromSliceUnchecked(s.inner[start:])
	}
	return ret
}

func (s *TypeIdTableV4) AsBuilder() TypeIdTableV4Builder {
	ret := NewTypeIdTableV4Builder().AccountCell(*s.AccountCell()).ApplyRegisterCell(*s.ApplyRegisterCell()).BalanceCell(*s.BalanceCell()).IncomeCell(*s.IncomeCell()).PreAccountCell(*s.PreAccountCell()).ProposalCell(*s.ProposalCell()).AccountSaleCell(*s.AccountSaleCell()).AccountAuctionCell(*s.AccountAuctionCell()).OfferCell(*s.OfferCell()).ReverseRecordCell(*s.ReverseRecordCell())
	return *ret
}

type ConfigCellMainV6Builder struct {
	status                   Uint8
	type_id_table            TypeIdTableV5
	das_lock_out_point_table DasLockOutPointTable
}

func (s *ConfigCellMainV6Builder) Build() ConfigCellMainV6 {
	b := new(bytes.Buffer)

	totalSize := HeaderSizeUint * (3 + 1)
	offsets := make([]uint32, 0, 3)

	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.status.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.type_id_table.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.das_lock_out_point_table.AsSlice()))

	b.Write(packNumber(Number(totalSize)))

	for i := 0; i < len(offsets); i++ {
		b.Write(packNumber(Number(offsets[i])))
	}

	b.Write(s.status.AsSlice())
	b.Write(s.type_id_table.AsSlice())
	b.Write(s.das_lock_out_point_table.AsSlice())
	return ConfigCellMainV6{inner: b.Bytes()}
}

func (s *ConfigCellMainV6Builder) Status(v Uint8) *ConfigCellMainV6Builder {
	s.status = v
	return s
}

func (s *ConfigCellMainV6Builder) TypeIdTable(v TypeIdTableV5) *ConfigCellMainV6Builder {
	s.type_id_table = v
	return s
}

func (s *ConfigCellMainV6Builder) DasLockOutPointTable(v DasLockOutPointTable) *ConfigCellMainV6Builder {
	s.das_lock_out_point_table = v
	return s
}

func NewConfigCellMainV6Builder() *ConfigCellMainV6Builder {
	return &ConfigCellMainV6Builder{status: Uint8Default(), type_id_table: TypeIdTableV5Default(), das_lock_out_point_table: DasLockOutPointTableDefault()}
}

type ConfigCellMainV6 struct {
	inner []byte
}

func ConfigCellMainV6FromSliceUnchecked(slice []byte) *ConfigCellMainV6 {
	return &ConfigCellMainV6{inner: slice}
}
func (s *ConfigCellMainV6) AsSlice() []byte {
	return s.inner
}

func ConfigCellMainV6Default() ConfigCellMainV6 {
	return *ConfigCellMainV6FromSliceUnchecked([]byte{149, 2, 0, 0, 16, 0, 0, 0, 17, 0, 0, 0, 161, 1, 0, 0, 0, 144, 1, 0, 0, 48, 0, 0, 0, 80, 0, 0, 0, 112, 0, 0, 0, 144, 0, 0, 0, 176, 0, 0, 0, 208, 0, 0, 0, 240, 0, 0, 0, 16, 1, 0, 0, 48, 1, 0, 0, 80, 1, 0, 0, 112, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 244, 0, 0, 0, 28, 0, 0, 0, 64, 0, 0, 0, 100, 0, 0, 0, 136, 0, 0, 0, 172, 0, 0, 0, 208, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0})
}

func ConfigCellMainV6FromSlice(slice []byte, compatible bool) (*ConfigCellMainV6, error) {
	sliceLen := len(slice)
	if uint32(sliceLen) < HeaderSizeUint {
		errMsg := strings.Join([]string{"HeaderIsBroken", "ConfigCellMainV6", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}

	totalSize := unpackNumber(slice)
	if Number(sliceLen) != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "ConfigCellMainV6", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}

	if uint32(sliceLen) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "ConfigCellMainV6", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	offsetFirst := unpackNumber(slice[HeaderSizeUint:])
	if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"OffsetsNotMatch", "ConfigCellMainV6", strconv.Itoa(int(offsetFirst % 4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	if sliceLen < int(offsetFirst) {
		errMsg := strings.Join([]string{"HeaderIsBroken", "ConfigCellMainV6", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
		return nil, errors.New(errMsg)
	}

	fieldCount := uint32(offsetFirst)/HeaderSizeUint - 1
	if fieldCount < 3 {
		return nil, errors.New("FieldCountNotMatch")
	} else if !compatible && fieldCount > 3 {
		return nil, errors.New("FieldCountNotMatch")
	}

	offsets := make([]uint32, fieldCount)

	for i := 0; i < int(fieldCount); i++ {
		offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
	}
	offsets = append(offsets, uint32(totalSize))

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 && offsets[i-1] > offsets[i] {
			return nil, errors.New("OffsetsNotMatch")
		}
	}

	var err error

	_, err = Uint8FromSlice(slice[offsets[0]:offsets[1]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = TypeIdTableV5FromSlice(slice[offsets[1]:offsets[2]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = DasLockOutPointTableFromSlice(slice[offsets[2]:offsets[3]], compatible)
	if err != nil {
		return nil, err
	}

	return &ConfigCellMainV6{inner: slice}, nil
}

func (s *ConfigCellMainV6) TotalSize() uint {
	return uint(unpackNumber(s.inner))
}
func (s *ConfigCellMainV6) FieldCount() uint {
	var number uint = 0
	if uint32(s.TotalSize()) == HeaderSizeUint {
		return number
	}
	number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
	return number
}
func (s *ConfigCellMainV6) Len() uint {
	return s.FieldCount()
}
func (s *ConfigCellMainV6) IsEmpty() bool {
	return s.Len() == 0
}
func (s *ConfigCellMainV6) CountExtraFields() uint {
	return s.FieldCount() - 3
}

func (s *ConfigCellMainV6) HasExtraFields() bool {
	return 3 != s.FieldCount()
}

func (s *ConfigCellMainV6) Status() *Uint8 {
	start := unpackNumber(s.inner[4:])
	end := unpackNumber(s.inner[8:])
	return Uint8FromSliceUnchecked(s.inner[start:end])
}

func (s *ConfigCellMainV6) TypeIdTable() *TypeIdTableV5 {
	start := unpackNumber(s.inner[8:])
	end := unpackNumber(s.inner[12:])
	return TypeIdTableV5FromSliceUnchecked(s.inner[start:end])
}

func (s *ConfigCellMainV6) DasLockOutPointTable() *DasLockOutPointTable {
	var ret *DasLockOutPointTable
	start := unpackNumber(s.inner[12:])
	if s.HasExtraFields() {
		end := unpackNumber(s.inner[16:])
		ret = DasLockOutPointTableFromSliceUnchecked(s.inner[start:end])
	} else {
		ret = DasLockOutPointTableFromSliceUnchecked(s.inner[start:])
	}
	return ret
}

func (s *ConfigCellMainV6) AsBuilder() ConfigCellMainV6Builder {
	ret := NewConfigCellMainV6Builder().Status(*s.Status()).TypeIdTable(*s.TypeIdTable()).DasLockOutPointTable(*s.DasLockOutPointTable())
	return *ret
}

type TypeIdTableV5Builder struct {
	account_cell         Hash
	apply_register_cell  Hash
	balance_cell         Hash
	income_cell          Hash
	pre_account_cell     Hash
	proposal_cell        Hash
	account_sale_cell    Hash
	account_auction_cell Hash
	offer_cell           Hash
	reverse_record_cell  Hash
	sub_account_cell     Hash
}

func (s *TypeIdTableV5Builder) Build() TypeIdTableV5 {
	b := new(bytes.Buffer)

	totalSize := HeaderSizeUint * (11 + 1)
	offsets := make([]uint32, 0, 11)

	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.account_cell.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.apply_register_cell.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.balance_cell.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.income_cell.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.pre_account_cell.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.proposal_cell.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.account_sale_cell.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.account_auction_cell.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.offer_cell.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.reverse_record_cell.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.sub_account_cell.AsSlice()))

	b.Write(packNumber(Number(totalSize)))

	for i := 0; i < len(offsets); i++ {
		b.Write(packNumber(Number(offsets[i])))
	}

	b.Write(s.account_cell.AsSlice())
	b.Write(s.apply_register_cell.AsSlice())
	b.Write(s.balance_cell.AsSlice())
	b.Write(s.income_cell.AsSlice())
	b.Write(s.pre_account_cell.AsSlice())
	b.Write(s.proposal_cell.AsSlice())
	b.Write(s.account_sale_cell.AsSlice())
	b.Write(s.account_auction_cell.AsSlice())
	b.Write(s.offer_cell.AsSlice())
	b.Write(s.reverse_record_cell.AsSlice())
	b.Write(s.sub_account_cell.AsSlice())
	return TypeIdTableV5{inner: b.Bytes()}
}

func (s *TypeIdTableV5Builder) AccountCell(v Hash) *TypeIdTableV5Builder {
	s.account_cell = v
	return s
}

func (s *TypeIdTableV5Builder) ApplyRegisterCell(v Hash) *TypeIdTableV5Builder {
	s.apply_register_cell = v
	return s
}

func (s *TypeIdTableV5Builder) BalanceCell(v Hash) *TypeIdTableV5Builder {
	s.balance_cell = v
	return s
}

func (s *TypeIdTableV5Builder) IncomeCell(v Hash) *TypeIdTableV5Builder {
	s.income_cell = v
	return s
}

func (s *TypeIdTableV5Builder) PreAccountCell(v Hash) *TypeIdTableV5Builder {
	s.pre_account_cell = v
	return s
}

func (s *TypeIdTableV5Builder) ProposalCell(v Hash) *TypeIdTableV5Builder {
	s.proposal_cell = v
	return s
}

func (s *TypeIdTableV5Builder) AccountSaleCell(v Hash) *TypeIdTableV5Builder {
	s.account_sale_cell = v
	return s
}

func (s *TypeIdTableV5Builder) AccountAuctionCell(v Hash) *TypeIdTableV5Builder {
	s.account_auction_cell = v
	return s
}

func (s *TypeIdTableV5Builder) OfferCell(v Hash) *TypeIdTableV5Builder {
	s.offer_cell = v
	return s
}

func (s *TypeIdTableV5Builder) ReverseRecordCell(v Hash) *TypeIdTableV5Builder {
	s.reverse_record_cell = v
	return s
}

func (s *TypeIdTableV5Builder) SubAccountCell(v Hash) *TypeIdTableV5Builder {
	s.sub_account_cell = v
	return s
}

func NewTypeIdTableV5Builder() *TypeIdTableV5Builder {
	return &TypeIdTableV5Builder{account_cell: HashDefault(), apply_register_cell: HashDefault(), balance_cell: HashDefault(), income_cell: HashDefault(), pre_account_cell: HashDefault(), proposal_cell: HashDefault(), account_sale_cell: HashDefault(), account_auction_cell: HashDefault(), offer_cell: HashDefault(), reverse_record_cell: HashDefault(), sub_account_cell: HashDefault()}
}

type TypeIdTableV5 struct {
	inner []byte
}

func TypeIdTableV5FromSliceUnchecked(slice []byte) *TypeIdTableV5 {
	return &TypeIdTableV5{inner: slice}
}
func (s *TypeIdTableV5) AsSlice() []byte {
	return s.inner
}

func TypeIdTableV5Default() TypeIdTableV5 {
	return *TypeIdTableV5FromSliceUnchecked([]byte{144, 1, 0, 0, 48, 0, 0, 0, 80, 0, 0, 0, 112, 0, 0, 0, 144, 0, 0, 0, 176, 0, 0, 0, 208, 0, 0, 0, 240, 0, 0, 0, 16, 1, 0, 0, 48, 1, 0, 0, 80, 1, 0, 0, 112, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0})
}

func TypeIdTableV5FromSlice(slice []byte, compatible bool) (*TypeIdTableV5, error) {
	sliceLen := len(slice)
	if uint32(sliceLen) < HeaderSizeUint {
		errMsg := strings.Join([]string{"HeaderIsBroken", "TypeIdTableV5", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}

	totalSize := unpackNumber(slice)
	if Number(sliceLen) != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "TypeIdTableV5", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}

	if uint32(sliceLen) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "TypeIdTableV5", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	offsetFirst := unpackNumber(slice[HeaderSizeUint:])
	if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"OffsetsNotMatch", "TypeIdTableV5", strconv.Itoa(int(offsetFirst % 4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	if sliceLen < int(offsetFirst) {
		errMsg := strings.Join([]string{"HeaderIsBroken", "TypeIdTableV5", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
		return nil, errors.New(errMsg)
	}

	fieldCount := uint32(offsetFirst)/HeaderSizeUint - 1
	if fieldCount < 11 {
		return nil, errors.New("FieldCountNotMatch")
	} else if !compatible && fieldCount > 11 {
		return nil, errors.New("FieldCountNotMatch")
	}

	offsets := make([]uint32, fieldCount)

	for i := 0; i < int(fieldCount); i++ {
		offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
	}
	offsets = append(offsets, uint32(totalSize))

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 && offsets[i-1] > offsets[i] {
			return nil, errors.New("OffsetsNotMatch")
		}
	}

	var err error

	_, err = HashFromSlice(slice[offsets[0]:offsets[1]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = HashFromSlice(slice[offsets[1]:offsets[2]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = HashFromSlice(slice[offsets[2]:offsets[3]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = HashFromSlice(slice[offsets[3]:offsets[4]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = HashFromSlice(slice[offsets[4]:offsets[5]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = HashFromSlice(slice[offsets[5]:offsets[6]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = HashFromSlice(slice[offsets[6]:offsets[7]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = HashFromSlice(slice[offsets[7]:offsets[8]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = HashFromSlice(slice[offsets[8]:offsets[9]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = HashFromSlice(slice[offsets[9]:offsets[10]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = HashFromSlice(slice[offsets[10]:offsets[11]], compatible)
	if err != nil {
		return nil, err
	}

	return &TypeIdTableV5{inner: slice}, nil
}

func (s *TypeIdTableV5) TotalSize() uint {
	return uint(unpackNumber(s.inner))
}
func (s *TypeIdTableV5) FieldCount() uint {
	var number uint = 0
	if uint32(s.TotalSize()) == HeaderSizeUint {
		return number
	}
	number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
	return number
}
func (s *TypeIdTableV5) Len() uint {
	return s.FieldCount()
}
func (s *TypeIdTableV5) IsEmpty() bool {
	return s.Len() == 0
}
func (s *TypeIdTableV5) CountExtraFields() uint {
	return s.FieldCount() - 11
}

func (s *TypeIdTableV5) HasExtraFields() bool {
	return 11 != s.FieldCount()
}

func (s *TypeIdTableV5) AccountCell() *Hash {
	start := unpackNumber(s.inner[4:])
	end := unpackNumber(s.inner[8:])
	return HashFromSliceUnchecked(s.inner[start:end])
}

func (s *TypeIdTableV5) ApplyRegisterCell() *Hash {
	start := unpackNumber(s.inner[8:])
	end := unpackNumber(s.inner[12:])
	return HashFromSliceUnchecked(s.inner[start:end])
}

func (s *TypeIdTableV5) BalanceCell() *Hash {
	start := unpackNumber(s.inner[12:])
	end := unpackNumber(s.inner[16:])
	return HashFromSliceUnchecked(s.inner[start:end])
}

func (s *TypeIdTableV5) IncomeCell() *Hash {
	start := unpackNumber(s.inner[16:])
	end := unpackNumber(s.inner[20:])
	return HashFromSliceUnchecked(s.inner[start:end])
}

func (s *TypeIdTableV5) PreAccountCell() *Hash {
	start := unpackNumber(s.inner[20:])
	end := unpackNumber(s.inner[24:])
	return HashFromSliceUnchecked(s.inner[start:end])
}

func (s *TypeIdTableV5) ProposalCell() *Hash {
	start := unpackNumber(s.inner[24:])
	end := unpackNumber(s.inner[28:])
	return HashFromSliceUnchecked(s.inner[start:end])
}

func (s *TypeIdTableV5) AccountSaleCell() *Hash {
	start := unpackNumber(s.inner[28:])
	end := unpackNumber(s.inner[32:])
	return HashFromSliceUnchecked(s.inner[start:end])
}

func (s *TypeIdTableV5) AccountAuctionCell() *Hash {
	start := unpackNumber(s.inner[32:])
	end := unpackNumber(s.inner[36:])
	return HashFromSliceUnchecked(s.inner[start:end])
}

func (s *TypeIdTableV5) OfferCell() *Hash {
	start := unpackNumber(s.inner[36:])
	end := unpackNumber(s.inner[40:])
	return HashFromSliceUnchecked(s.inner[start:end])
}

func (s *TypeIdTableV5) ReverseRecordCell() *Hash {
	start := unpackNumber(s.inner[40:])
	end := unpackNumber(s.inner[44:])
	return HashFromSliceUnchecked(s.inner[start:end])
}

func (s *TypeIdTableV5) SubAccountCell() *Hash {
	var ret *Hash
	start := unpackNumber(s.inner[44:])
	if s.HasExtraFields() {
		end := unpackNumber(s.inner[48:])
		ret = HashFromSliceUnchecked(s.inner[start:end])
	} else {
		ret = HashFromSliceUnchecked(s.inner[start:])
	}
	return ret
}

func (s *TypeIdTableV5) AsBuilder() TypeIdTableV5Builder {
	ret := NewTypeIdTableV5Builder().AccountCell(*s.AccountCell()).ApplyRegisterCell(*s.ApplyRegisterCell()).BalanceCell(*s.BalanceCell()).IncomeCell(*s.IncomeCell()).PreAccountCell(*s.PreAccountCell()).ProposalCell(*s.ProposalCell()).AccountSaleCell(*s.AccountSaleCell()).AccountAuctionCell(*s.AccountAuctionCell()).OfferCell(*s.OfferCell()).ReverseRecordCell(*s.ReverseRecordCell()).SubAccountCell(*s.SubAccountCell())
	return *ret
}

type ConfigCellMainV7Builder struct {
	status                   Uint8
	type_id_table            TypeIdTableV5
	das_lock_out_point_table DasLockOutPointTable
}

func (s *ConfigCellMainV7Builder) Build() ConfigCellMainV7 {
	b := new(bytes.Buffer)

	totalSize := HeaderSizeUint * (3 + 1)
	offsets := make([]uint32, 0, 3)

	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.status.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.type_id_table.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.das_lock_out_point_table.AsSlice()))

	b.Write(packNumber(Number(totalSize)))

	for i := 0; i < len(offsets); i++ {
		b.Write(packNumber(Number(offsets[i])))
	}

	b.Write(s.status.AsSlice())
	b.Write(s.type_id_table.AsSlice())
	b.Write(s.das_lock_out_point_table.AsSlice())
	return ConfigCellMainV7{inner: b.Bytes()}
}

func (s *ConfigCellMainV7Builder) Status(v Uint8) *ConfigCellMainV7Builder {
	s.status = v
	return s
}

func (s *ConfigCellMainV7Builder) TypeIdTable(v TypeIdTableV5) *ConfigCellMainV7Builder {
	s.type_id_table = v
	return s
}

func (s *ConfigCellMainV7Builder) DasLockOutPointTable(v DasLockOutPointTable) *ConfigCellMainV7Builder {
	s.das_lock_out_point_table = v
	return s
}

func NewConfigCellMainV7Builder() *ConfigCellMainV7Builder {
	return &ConfigCellMainV7Builder{status: Uint8Default(), type_id_table: TypeIdTableV5Default(), das_lock_out_point_table: DasLockOutPointTableDefault()}
}

type ConfigCellMainV7 struct {
	inner []byte
}

func ConfigCellMainV7FromSliceUnchecked(slice []byte) *ConfigCellMainV7 {
	return &ConfigCellMainV7{inner: slice}
}
func (s *ConfigCellMainV7) AsSlice() []byte {
	return s.inner
}

func ConfigCellMainV7Default() ConfigCellMainV7 {
	return *ConfigCellMainV7FromSliceUnchecked([]byte{149, 2, 0, 0, 16, 0, 0, 0, 17, 0, 0, 0, 161, 1, 0, 0, 0, 144, 1, 0, 0, 48, 0, 0, 0, 80, 0, 0, 0, 112, 0, 0, 0, 144, 0, 0, 0, 176, 0, 0, 0, 208, 0, 0, 0, 240, 0, 0, 0, 16, 1, 0, 0, 48, 1, 0, 0, 80, 1, 0, 0, 112, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 244, 0, 0, 0, 28, 0, 0, 0, 64, 0, 0, 0, 100, 0, 0, 0, 136, 0, 0, 0, 172, 0, 0, 0, 208, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0})
}

func ConfigCellMainV7FromSlice(slice []byte, compatible bool) (*ConfigCellMainV7, error) {
	sliceLen := len(slice)
	if uint32(sliceLen) < HeaderSizeUint {
		errMsg := strings.Join([]string{"HeaderIsBroken", "ConfigCellMainV7", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}

	totalSize := unpackNumber(slice)
	if Number(sliceLen) != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "ConfigCellMainV7", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}

	if uint32(sliceLen) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "ConfigCellMainV7", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	offsetFirst := unpackNumber(slice[HeaderSizeUint:])
	if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"OffsetsNotMatch", "ConfigCellMainV7", strconv.Itoa(int(offsetFirst % 4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	if sliceLen < int(offsetFirst) {
		errMsg := strings.Join([]string{"HeaderIsBroken", "ConfigCellMainV7", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
		return nil, errors.New(errMsg)
	}

	fieldCount := uint32(offsetFirst)/HeaderSizeUint - 1
	if fieldCount < 3 {
		return nil, errors.New("FieldCountNotMatch")
	} else if !compatible && fieldCount > 3 {
		return nil, errors.New("FieldCountNotMatch")
	}

	offsets := make([]uint32, fieldCount)

	for i := 0; i < int(fieldCount); i++ {
		offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
	}
	offsets = append(offsets, uint32(totalSize))

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 && offsets[i-1] > offsets[i] {
			return nil, errors.New("OffsetsNotMatch")
		}
	}

	var err error

	_, err = Uint8FromSlice(slice[offsets[0]:offsets[1]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = TypeIdTableV5FromSlice(slice[offsets[1]:offsets[2]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = DasLockOutPointTableFromSlice(slice[offsets[2]:offsets[3]], compatible)
	if err != nil {
		return nil, err
	}

	return &ConfigCellMainV7{inner: slice}, nil
}

func (s *ConfigCellMainV7) TotalSize() uint {
	return uint(unpackNumber(s.inner))
}
func (s *ConfigCellMainV7) FieldCount() uint {
	var number uint = 0
	if uint32(s.TotalSize()) == HeaderSizeUint {
		return number
	}
	number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
	return number
}
func (s *ConfigCellMainV7) Len() uint {
	return s.FieldCount()
}
func (s *ConfigCellMainV7) IsEmpty() bool {
	return s.Len() == 0
}
func (s *ConfigCellMainV7) CountExtraFields() uint {
	return s.FieldCount() - 3
}

func (s *ConfigCellMainV7) HasExtraFields() bool {
	return 3 != s.FieldCount()
}

func (s *ConfigCellMainV7) Status() *Uint8 {
	start := unpackNumber(s.inner[4:])
	end := unpackNumber(s.inner[8:])
	return Uint8FromSliceUnchecked(s.inner[start:end])
}

func (s *ConfigCellMainV7) TypeIdTable() *TypeIdTableV5 {
	start := unpackNumber(s.inner[8:])
	end := unpackNumber(s.inner[12:])
	return TypeIdTableV5FromSliceUnchecked(s.inner[start:end])
}

func (s *ConfigCellMainV7) DasLockOutPointTable() *DasLockOutPointTable {
	var ret *DasLockOutPointTable
	start := unpackNumber(s.inner[12:])
	if s.HasExtraFields() {
		end := unpackNumber(s.inner[16:])
		ret = DasLockOutPointTableFromSliceUnchecked(s.inner[start:end])
	} else {
		ret = DasLockOutPointTableFromSliceUnchecked(s.inner[start:])
	}
	return ret
}

func (s *ConfigCellMainV7) AsBuilder() ConfigCellMainV7Builder {
	ret := NewConfigCellMainV7Builder().Status(*s.Status()).TypeIdTable(*s.TypeIdTable()).DasLockOutPointTable(*s.DasLockOutPointTable())
	return *ret
}

type TypeIdTableV6Builder struct {
	account_cell         Hash
	apply_register_cell  Hash
	balance_cell         Hash
	income_cell          Hash
	pre_account_cell     Hash
	proposal_cell        Hash
	account_sale_cell    Hash
	account_auction_cell Hash
	offer_cell           Hash
	reverse_record_cell  Hash
	sub_account_cell     Hash
	eip712_lib           Hash
}

func (s *TypeIdTableV6Builder) Build() TypeIdTableV6 {
	b := new(bytes.Buffer)

	totalSize := HeaderSizeUint * (12 + 1)
	offsets := make([]uint32, 0, 12)

	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.account_cell.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.apply_register_cell.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.balance_cell.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.income_cell.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.pre_account_cell.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.proposal_cell.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.account_sale_cell.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.account_auction_cell.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.offer_cell.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.reverse_record_cell.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.sub_account_cell.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.eip712_lib.AsSlice()))

	b.Write(packNumber(Number(totalSize)))

	for i := 0; i < len(offsets); i++ {
		b.Write(packNumber(Number(offsets[i])))
	}

	b.Write(s.account_cell.AsSlice())
	b.Write(s.apply_register_cell.AsSlice())
	b.Write(s.balance_cell.AsSlice())
	b.Write(s.income_cell.AsSlice())
	b.Write(s.pre_account_cell.AsSlice())
	b.Write(s.proposal_cell.AsSlice())
	b.Write(s.account_sale_cell.AsSlice())
	b.Write(s.account_auction_cell.AsSlice())
	b.Write(s.offer_cell.AsSlice())
	b.Write(s.reverse_record_cell.AsSlice())
	b.Write(s.sub_account_cell.AsSlice())
	b.Write(s.eip712_lib.AsSlice())
	return TypeIdTableV6{inner: b.Bytes()}
}

func (s *TypeIdTableV6Builder) AccountCell(v Hash) *TypeIdTableV6Builder {
	s.account_cell = v
	return s
}

func (s *TypeIdTableV6Builder) ApplyRegisterCell(v Hash) *TypeIdTableV6Builder {
	s.apply_register_cell = v
	return s
}

func (s *TypeIdTableV6Builder) BalanceCell(v Hash) *TypeIdTableV6Builder {
	s.balance_cell = v
	return s
}

func (s *TypeIdTableV6Builder) IncomeCell(v Hash) *TypeIdTableV6Builder {
	s.income_cell = v
	return s
}

func (s *TypeIdTableV6Builder) PreAccountCell(v Hash) *TypeIdTableV6Builder {
	s.pre_account_cell = v
	return s
}

func (s *TypeIdTableV6Builder) ProposalCell(v Hash) *TypeIdTableV6Builder {
	s.proposal_cell = v
	return s
}

func (s *TypeIdTableV6Builder) AccountSaleCell(v Hash) *TypeIdTableV6Builder {
	s.account_sale_cell = v
	return s
}

func (s *TypeIdTableV6Builder) AccountAuctionCell(v Hash) *TypeIdTableV6Builder {
	s.account_auction_cell = v
	return s
}

func (s *TypeIdTableV6Builder) OfferCell(v Hash) *TypeIdTableV6Builder {
	s.offer_cell = v
	return s
}

func (s *TypeIdTableV6Builder) ReverseRecordCell(v Hash) *TypeIdTableV6Builder {
	s.reverse_record_cell = v
	return s
}

func (s *TypeIdTableV6Builder) SubAccountCell(v Hash) *TypeIdTableV6Builder {
	s.sub_account_cell = v
	return s
}

func (s *TypeIdTableV6Builder) Eip712Lib(v Hash) *TypeIdTableV6Builder {
	s.eip712_lib = v
	return s
}

func NewTypeIdTableV6Builder() *TypeIdTableV6Builder {
	return &TypeIdTableV6Builder{account_cell: HashDefault(), apply_register_cell: HashDefault(), balance_cell: HashDefault(), income_cell: HashDefault(), pre_account_cell: HashDefault(), proposal_cell: HashDefault(), account_sale_cell: HashDefault(), account_auction_cell: HashDefault(), offer_cell: HashDefault(), reverse_record_cell: HashDefault(), sub_account_cell: HashDefault(), eip712_lib: HashDefault()}
}

type TypeIdTableV6 struct {
	inner []byte
}

func TypeIdTableV6FromSliceUnchecked(slice []byte) *TypeIdTableV6 {
	return &TypeIdTableV6{inner: slice}
}
func (s *TypeIdTableV6) AsSlice() []byte {
	return s.inner
}

func TypeIdTableV6Default() TypeIdTableV6 {
	return *TypeIdTableV6FromSliceUnchecked([]byte{180, 1, 0, 0, 52, 0, 0, 0, 84, 0, 0, 0, 116, 0, 0, 0, 148, 0, 0, 0, 180, 0, 0, 0, 212, 0, 0, 0, 244, 0, 0, 0, 20, 1, 0, 0, 52, 1, 0, 0, 84, 1, 0, 0, 116, 1, 0, 0, 148, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0})
}

func TypeIdTableV6FromSlice(slice []byte, compatible bool) (*TypeIdTableV6, error) {
	sliceLen := len(slice)
	if uint32(sliceLen) < HeaderSizeUint {
		errMsg := strings.Join([]string{"HeaderIsBroken", "TypeIdTableV6", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}

	totalSize := unpackNumber(slice)
	if Number(sliceLen) != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "TypeIdTableV6", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}

	if uint32(sliceLen) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "TypeIdTableV6", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	offsetFirst := unpackNumber(slice[HeaderSizeUint:])
	if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"OffsetsNotMatch", "TypeIdTableV6", strconv.Itoa(int(offsetFirst % 4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	if sliceLen < int(offsetFirst) {
		errMsg := strings.Join([]string{"HeaderIsBroken", "TypeIdTableV6", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
		return nil, errors.New(errMsg)
	}

	fieldCount := uint32(offsetFirst)/HeaderSizeUint - 1
	if fieldCount < 12 {
		return nil, errors.New("FieldCountNotMatch")
	} else if !compatible && fieldCount > 12 {
		return nil, errors.New("FieldCountNotMatch")
	}

	offsets := make([]uint32, fieldCount)

	for i := 0; i < int(fieldCount); i++ {
		offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
	}
	offsets = append(offsets, uint32(totalSize))

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 && offsets[i-1] > offsets[i] {
			return nil, errors.New("OffsetsNotMatch")
		}
	}

	var err error

	_, err = HashFromSlice(slice[offsets[0]:offsets[1]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = HashFromSlice(slice[offsets[1]:offsets[2]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = HashFromSlice(slice[offsets[2]:offsets[3]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = HashFromSlice(slice[offsets[3]:offsets[4]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = HashFromSlice(slice[offsets[4]:offsets[5]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = HashFromSlice(slice[offsets[5]:offsets[6]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = HashFromSlice(slice[offsets[6]:offsets[7]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = HashFromSlice(slice[offsets[7]:offsets[8]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = HashFromSlice(slice[offsets[8]:offsets[9]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = HashFromSlice(slice[offsets[9]:offsets[10]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = HashFromSlice(slice[offsets[10]:offsets[11]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = HashFromSlice(slice[offsets[11]:offsets[12]], compatible)
	if err != nil {
		return nil, err
	}

	return &TypeIdTableV6{inner: slice}, nil
}

func (s *TypeIdTableV6) TotalSize() uint {
	return uint(unpackNumber(s.inner))
}
func (s *TypeIdTableV6) FieldCount() uint {
	var number uint = 0
	if uint32(s.TotalSize()) == HeaderSizeUint {
		return number
	}
	number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
	return number
}
func (s *TypeIdTableV6) Len() uint {
	return s.FieldCount()
}
func (s *TypeIdTableV6) IsEmpty() bool {
	return s.Len() == 0
}
func (s *TypeIdTableV6) CountExtraFields() uint {
	return s.FieldCount() - 12
}

func (s *TypeIdTableV6) HasExtraFields() bool {
	return 12 != s.FieldCount()
}

func (s *TypeIdTableV6) AccountCell() *Hash {
	start := unpackNumber(s.inner[4:])
	end := unpackNumber(s.inner[8:])
	return HashFromSliceUnchecked(s.inner[start:end])
}

func (s *TypeIdTableV6) ApplyRegisterCell() *Hash {
	start := unpackNumber(s.inner[8:])
	end := unpackNumber(s.inner[12:])
	return HashFromSliceUnchecked(s.inner[start:end])
}

func (s *TypeIdTableV6) BalanceCell() *Hash {
	start := unpackNumber(s.inner[12:])
	end := unpackNumber(s.inner[16:])
	return HashFromSliceUnchecked(s.inner[start:end])
}

func (s *TypeIdTableV6) IncomeCell() *Hash {
	start := unpackNumber(s.inner[16:])
	end := unpackNumber(s.inner[20:])
	return HashFromSliceUnchecked(s.inner[start:end])
}

func (s *TypeIdTableV6) PreAccountCell() *Hash {
	start := unpackNumber(s.inner[20:])
	end := unpackNumber(s.inner[24:])
	return HashFromSliceUnchecked(s.inner[start:end])
}

func (s *TypeIdTableV6) ProposalCell() *Hash {
	start := unpackNumber(s.inner[24:])
	end := unpackNumber(s.inner[28:])
	return HashFromSliceUnchecked(s.inner[start:end])
}

func (s *TypeIdTableV6) AccountSaleCell() *Hash {
	start := unpackNumber(s.inner[28:])
	end := unpackNumber(s.inner[32:])
	return HashFromSliceUnchecked(s.inner[start:end])
}

func (s *TypeIdTableV6) AccountAuctionCell() *Hash {
	start := unpackNumber(s.inner[32:])
	end := unpackNumber(s.inner[36:])
	return HashFromSliceUnchecked(s.inner[start:end])
}

func (s *TypeIdTableV6) OfferCell() *Hash {
	start := unpackNumber(s.inner[36:])
	end := unpackNumber(s.inner[40:])
	return HashFromSliceUnchecked(s.inner[start:end])
}

func (s *TypeIdTableV6) ReverseRecordCell() *Hash {
	start := unpackNumber(s.inner[40:])
	end := unpackNumber(s.inner[44:])
	return HashFromSliceUnchecked(s.inner[start:end])
}

func (s *TypeIdTableV6) SubAccountCell() *Hash {
	start := unpackNumber(s.inner[44:])
	end := unpackNumber(s.inner[48:])
	return HashFromSliceUnchecked(s.inner[start:end])
}

func (s *TypeIdTableV6) Eip712Lib() *Hash {
	var ret *Hash
	start := unpackNumber(s.inner[48:])
	if s.HasExtraFields() {
		end := unpackNumber(s.inner[52:])
		ret = HashFromSliceUnchecked(s.inner[start:end])
	} else {
		ret = HashFromSliceUnchecked(s.inner[start:])
	}
	return ret
}

func (s *TypeIdTableV6) AsBuilder() TypeIdTableV6Builder {
	ret := NewTypeIdTableV6Builder().AccountCell(*s.AccountCell()).ApplyRegisterCell(*s.ApplyRegisterCell()).BalanceCell(*s.BalanceCell()).IncomeCell(*s.IncomeCell()).PreAccountCell(*s.PreAccountCell()).ProposalCell(*s.ProposalCell()).AccountSaleCell(*s.AccountSaleCell()).AccountAuctionCell(*s.AccountAuctionCell()).OfferCell(*s.OfferCell()).ReverseRecordCell(*s.ReverseRecordCell()).SubAccountCell(*s.SubAccountCell()).Eip712Lib(*s.Eip712Lib())
	return *ret
}

type ConfigCellAccountV1Builder struct {
	max_length                Uint32
	basic_capacity            Uint64
	prepared_fee_capacity     Uint64
	expiration_grace_period   Uint32
	record_min_ttl            Uint32
	record_size_limit         Uint32
	transfer_account_fee      Uint64
	edit_manager_fee          Uint64
	edit_records_fee          Uint64
	transfer_account_throttle Uint32
	edit_manager_throttle     Uint32
	edit_records_throttle     Uint32
}

func (s *ConfigCellAccountV1Builder) Build() ConfigCellAccountV1 {
	b := new(bytes.Buffer)

	totalSize := HeaderSizeUint * (12 + 1)
	offsets := make([]uint32, 0, 12)

	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.max_length.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.basic_capacity.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.prepared_fee_capacity.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.expiration_grace_period.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.record_min_ttl.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.record_size_limit.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.transfer_account_fee.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.edit_manager_fee.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.edit_records_fee.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.transfer_account_throttle.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.edit_manager_throttle.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.edit_records_throttle.AsSlice()))

	b.Write(packNumber(Number(totalSize)))

	for i := 0; i < len(offsets); i++ {
		b.Write(packNumber(Number(offsets[i])))
	}

	b.Write(s.max_length.AsSlice())
	b.Write(s.basic_capacity.AsSlice())
	b.Write(s.prepared_fee_capacity.AsSlice())
	b.Write(s.expiration_grace_period.AsSlice())
	b.Write(s.record_min_ttl.AsSlice())
	b.Write(s.record_size_limit.AsSlice())
	b.Write(s.transfer_account_fee.AsSlice())
	b.Write(s.edit_manager_fee.AsSlice())
	b.Write(s.edit_records_fee.AsSlice())
	b.Write(s.transfer_account_throttle.AsSlice())
	b.Write(s.edit_manager_throttle.AsSlice())
	b.Write(s.edit_records_throttle.AsSlice())
	return ConfigCellAccountV1{inner: b.Bytes()}
}

func (s *ConfigCellAccountV1Builder) MaxLength(v Uint32) *ConfigCellAccountV1Builder {
	s.max_length = v
	return s
}

func (s *ConfigCellAccountV1Builder) BasicCapacity(v Uint64) *ConfigCellAccountV1Builder {
	s.basic_capacity = v
	return s
}

func (s *ConfigCellAccountV1Builder) PreparedFeeCapacity(v Uint64) *ConfigCellAccountV1Builder {
	s.prepared_fee_capacity = v
	return s
}

func (s *ConfigCellAccountV1Builder) ExpirationGracePeriod(v Uint32) *ConfigCellAccountV1Builder {
	s.expiration_grace_period = v
	return s
}

func (s *ConfigCellAccountV1Builder) RecordMinTtl(v Uint32) *ConfigCellAccountV1Builder {
	s.record_min_ttl = v
	return s
}

func (s *ConfigCellAccountV1Builder) RecordSizeLimit(v Uint32) *ConfigCellAccountV1Builder {
	s.record_size_limit = v
	return s
}

func (s *ConfigCellAccountV1Builder) TransferAccountFee(v Uint64) *ConfigCellAccountV1Builder {
	s.transfer_account_fee = v
	return s
}

func (s *ConfigCellAccountV1Builder) EditManagerFee(v Uint64) *ConfigCellAccountV1Builder {
	s.edit_manager_fee = v
	return s
}

func (s *ConfigCellAccountV1Builder) EditRecordsFee(v Uint64) *ConfigCellAccountV1Builder {
	s.edit_records_fee = v
	return s
}

func (s *ConfigCellAccountV1Builder) TransferAccountThrottle(v Uint32) *ConfigCellAccountV1Builder {
	s.transfer_account_throttle = v
	return s
}

func (s *ConfigCellAccountV1Builder) EditManagerThrottle(v Uint32) *ConfigCellAccountV1Builder {
	s.edit_manager_throttle = v
	return s
}

func (s *ConfigCellAccountV1Builder) EditRecordsThrottle(v Uint32) *ConfigCellAccountV1Builder {
	s.edit_records_throttle = v
	return s
}

func NewConfigCellAccountV1Builder() *ConfigCellAccountV1Builder {
	return &ConfigCellAccountV1Builder{max_length: Uint32Default(), basic_capacity: Uint64Default(), prepared_fee_capacity: Uint64Default(), expiration_grace_period: Uint32Default(), record_min_ttl: Uint32Default(), record_size_limit: Uint32Default(), transfer_account_fee: Uint64Default(), edit_manager_fee: Uint64Default(), edit_records_fee: Uint64Default(), transfer_account_throttle: Uint32Default(), edit_manager_throttle: Uint32Default(), edit_records_throttle: Uint32Default()}
}

type ConfigCellAccountV1 struct {
	inner []byte
}

func ConfigCellAccountV1FromSliceUnchecked(slice []byte) *ConfigCellAccountV1 {
	return &ConfigCellAccountV1{inner: slice}
}
func (s *ConfigCellAccountV1) AsSlice() []byte {
	return s.inner
}

func ConfigCellAccountV1Default() ConfigCellAccountV1 {
	return *ConfigCellAccountV1FromSliceUnchecked([]byte{120, 0, 0, 0, 52, 0, 0, 0, 56, 0, 0, 0, 64, 0, 0, 0, 72, 0, 0, 0, 76, 0, 0, 0, 80, 0, 0, 0, 84, 0, 0, 0, 92, 0, 0, 0, 100, 0, 0, 0, 108, 0, 0, 0, 112, 0, 0, 0, 116, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0})
}

func ConfigCellAccountV1FromSlice(slice []byte, compatible bool) (*ConfigCellAccountV1, error) {
	sliceLen := len(slice)
	if uint32(sliceLen) < HeaderSizeUint {
		errMsg := strings.Join([]string{"HeaderIsBroken", "ConfigCellAccountV1", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}

	totalSize := unpackNumber(slice)
	if Number(sliceLen) != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "ConfigCellAccountV1", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}

	if uint32(sliceLen) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "ConfigCellAccountV1", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	offsetFirst := unpackNumber(slice[HeaderSizeUint:])
	if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"OffsetsNotMatch", "ConfigCellAccountV1", strconv.Itoa(int(offsetFirst % 4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	if sliceLen < int(offsetFirst) {
		errMsg := strings.Join([]string{"HeaderIsBroken", "ConfigCellAccountV1", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
		return nil, errors.New(errMsg)
	}

	fieldCount := uint32(offsetFirst)/HeaderSizeUint - 1
	if fieldCount < 12 {
		return nil, errors.New("FieldCountNotMatch")
	} else if !compatible && fieldCount > 12 {
		return nil, errors.New("FieldCountNotMatch")
	}

	offsets := make([]uint32, fieldCount)

	for i := 0; i < int(fieldCount); i++ {
		offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
	}
	offsets = append(offsets, uint32(totalSize))

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 && offsets[i-1] > offsets[i] {
			return nil, errors.New("OffsetsNotMatch")
		}
	}

	var err error

	_, err = Uint32FromSlice(slice[offsets[0]:offsets[1]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = Uint64FromSlice(slice[offsets[1]:offsets[2]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = Uint64FromSlice(slice[offsets[2]:offsets[3]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = Uint32FromSlice(slice[offsets[3]:offsets[4]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = Uint32FromSlice(slice[offsets[4]:offsets[5]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = Uint32FromSlice(slice[offsets[5]:offsets[6]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = Uint64FromSlice(slice[offsets[6]:offsets[7]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = Uint64FromSlice(slice[offsets[7]:offsets[8]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = Uint64FromSlice(slice[offsets[8]:offsets[9]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = Uint32FromSlice(slice[offsets[9]:offsets[10]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = Uint32FromSlice(slice[offsets[10]:offsets[11]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = Uint32FromSlice(slice[offsets[11]:offsets[12]], compatible)
	if err != nil {
		return nil, err
	}

	return &ConfigCellAccountV1{inner: slice}, nil
}

func (s *ConfigCellAccountV1) TotalSize() uint {
	return uint(unpackNumber(s.inner))
}
func (s *ConfigCellAccountV1) FieldCount() uint {
	var number uint = 0
	if uint32(s.TotalSize()) == HeaderSizeUint {
		return number
	}
	number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
	return number
}
func (s *ConfigCellAccountV1) Len() uint {
	return s.FieldCount()
}
func (s *ConfigCellAccountV1) IsEmpty() bool {
	return s.Len() == 0
}
func (s *ConfigCellAccountV1) CountExtraFields() uint {
	return s.FieldCount() - 12
}

func (s *ConfigCellAccountV1) HasExtraFields() bool {
	return 12 != s.FieldCount()
}

func (s *ConfigCellAccountV1) MaxLength() *Uint32 {
	start := unpackNumber(s.inner[4:])
	end := unpackNumber(s.inner[8:])
	return Uint32FromSliceUnchecked(s.inner[start:end])
}

func (s *ConfigCellAccountV1) BasicCapacity() *Uint64 {
	start := unpackNumber(s.inner[8:])
	end := unpackNumber(s.inner[12:])
	return Uint64FromSliceUnchecked(s.inner[start:end])
}

func (s *ConfigCellAccountV1) PreparedFeeCapacity() *Uint64 {
	start := unpackNumber(s.inner[12:])
	end := unpackNumber(s.inner[16:])
	return Uint64FromSliceUnchecked(s.inner[start:end])
}

func (s *ConfigCellAccountV1) ExpirationGracePeriod() *Uint32 {
	start := unpackNumber(s.inner[16:])
	end := unpackNumber(s.inner[20:])
	return Uint32FromSliceUnchecked(s.inner[start:end])
}

func (s *ConfigCellAccountV1) RecordMinTtl() *Uint32 {
	start := unpackNumber(s.inner[20:])
	end := unpackNumber(s.inner[24:])
	return Uint32FromSliceUnchecked(s.inner[start:end])
}

func (s *ConfigCellAccountV1) RecordSizeLimit() *Uint32 {
	start := unpackNumber(s.inner[24:])
	end := unpackNumber(s.inner[28:])
	return Uint32FromSliceUnchecked(s.inner[start:end])
}

func (s *ConfigCellAccountV1) TransferAccountFee() *Uint64 {
	start := unpackNumber(s.inner[28:])
	end := unpackNumber(s.inner[32:])
	return Uint64FromSliceUnchecked(s.inner[start:end])
}

func (s *ConfigCellAccountV1) EditManagerFee() *Uint64 {
	start := unpackNumber(s.inner[32:])
	end := unpackNumber(s.inner[36:])
	return Uint64FromSliceUnchecked(s.inner[start:end])
}

func (s *ConfigCellAccountV1) EditRecordsFee() *Uint64 {
	start := unpackNumber(s.inner[36:])
	end := unpackNumber(s.inner[40:])
	return Uint64FromSliceUnchecked(s.inner[start:end])
}

func (s *ConfigCellAccountV1) TransferAccountThrottle() *Uint32 {
	start := unpackNumber(s.inner[40:])
	end := unpackNumber(s.inner[44:])
	return Uint32FromSliceUnchecked(s.inner[start:end])
}

func (s *ConfigCellAccountV1) EditManagerThrottle() *Uint32 {
	start := unpackNumber(s.inner[44:])
	end := unpackNumber(s.inner[48:])
	return Uint32FromSliceUnchecked(s.inner[start:end])
}

func (s *ConfigCellAccountV1) EditRecordsThrottle() *Uint32 {
	var ret *Uint32
	start := unpackNumber(s.inner[48:])
	if s.HasExtraFields() {
		end := unpackNumber(s.inner[52:])
		ret = Uint32FromSliceUnchecked(s.inner[start:end])
	} else {
		ret = Uint32FromSliceUnchecked(s.inner[start:])
	}
	return ret
}

func (s *ConfigCellAccountV1) AsBuilder() ConfigCellAccountV1Builder {
	ret := NewConfigCellAccountV1Builder().MaxLength(*s.MaxLength()).BasicCapacity(*s.BasicCapacity()).PreparedFeeCapacity(*s.PreparedFeeCapacity()).ExpirationGracePeriod(*s.ExpirationGracePeriod()).RecordMinTtl(*s.RecordMinTtl()).RecordSizeLimit(*s.RecordSizeLimit()).TransferAccountFee(*s.TransferAccountFee()).EditManagerFee(*s.EditManagerFee()).EditRecordsFee(*s.EditRecordsFee()).TransferAccountThrottle(*s.TransferAccountThrottle()).EditManagerThrottle(*s.EditManagerThrottle()).EditRecordsThrottle(*s.EditRecordsThrottle())
	return *ret
}

type ConfigCellProfitRateV1Builder struct {
	inviter            Uint32
	channel            Uint32
	proposal_create    Uint32
	proposal_confirm   Uint32
	income_consolidate Uint32
}

func (s *ConfigCellProfitRateV1Builder) Build() ConfigCellProfitRateV1 {
	b := new(bytes.Buffer)

	totalSize := HeaderSizeUint * (5 + 1)
	offsets := make([]uint32, 0, 5)

	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.inviter.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.channel.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.proposal_create.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.proposal_confirm.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.income_consolidate.AsSlice()))

	b.Write(packNumber(Number(totalSize)))

	for i := 0; i < len(offsets); i++ {
		b.Write(packNumber(Number(offsets[i])))
	}

	b.Write(s.inviter.AsSlice())
	b.Write(s.channel.AsSlice())
	b.Write(s.proposal_create.AsSlice())
	b.Write(s.proposal_confirm.AsSlice())
	b.Write(s.income_consolidate.AsSlice())
	return ConfigCellProfitRateV1{inner: b.Bytes()}
}

func (s *ConfigCellProfitRateV1Builder) Inviter(v Uint32) *ConfigCellProfitRateV1Builder {
	s.inviter = v
	return s
}

func (s *ConfigCellProfitRateV1Builder) Channel(v Uint32) *ConfigCellProfitRateV1Builder {
	s.channel = v
	return s
}

func (s *ConfigCellProfitRateV1Builder) ProposalCreate(v Uint32) *ConfigCellProfitRateV1Builder {
	s.proposal_create = v
	return s
}

func (s *ConfigCellProfitRateV1Builder) ProposalConfirm(v Uint32) *ConfigCellProfitRateV1Builder {
	s.proposal_confirm = v
	return s
}

func (s *ConfigCellProfitRateV1Builder) IncomeConsolidate(v Uint32) *ConfigCellProfitRateV1Builder {
	s.income_consolidate = v
	return s
}

func NewConfigCellProfitRateV1Builder() *ConfigCellProfitRateV1Builder {
	return &ConfigCellProfitRateV1Builder{inviter: Uint32Default(), channel: Uint32Default(), proposal_create: Uint32Default(), proposal_confirm: Uint32Default(), income_consolidate: Uint32Default()}
}

type ConfigCellProfitRateV1 struct {
	inner []byte
}

func ConfigCellProfitRateV1FromSliceUnchecked(slice []byte) *ConfigCellProfitRateV1 {
	return &ConfigCellProfitRateV1{inner: slice}
}
func (s *ConfigCellProfitRateV1) AsSlice() []byte {
	return s.inner
}

func ConfigCellProfitRateV1Default() ConfigCellProfitRateV1 {
	return *ConfigCellProfitRateV1FromSliceUnchecked([]byte{44, 0, 0, 0, 24, 0, 0, 0, 28, 0, 0, 0, 32, 0, 0, 0, 36, 0, 0, 0, 40, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0})
}

func ConfigCellProfitRateV1FromSlice(slice []byte, compatible bool) (*ConfigCellProfitRateV1, error) {
	sliceLen := len(slice)
	if uint32(sliceLen) < HeaderSizeUint {
		errMsg := strings.Join([]string{"HeaderIsBroken", "ConfigCellProfitRateV1", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}

	totalSize := unpackNumber(slice)
	if Number(sliceLen) != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "ConfigCellProfitRateV1", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}

	if uint32(sliceLen) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "ConfigCellProfitRateV1", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	offsetFirst := unpackNumber(slice[HeaderSizeUint:])
	if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"OffsetsNotMatch", "ConfigCellProfitRateV1", strconv.Itoa(int(offsetFirst % 4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	if sliceLen < int(offsetFirst) {
		errMsg := strings.Join([]string{"HeaderIsBroken", "ConfigCellProfitRateV1", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
		return nil, errors.New(errMsg)
	}

	fieldCount := uint32(offsetFirst)/HeaderSizeUint - 1
	if fieldCount < 5 {
		return nil, errors.New("FieldCountNotMatch")
	} else if !compatible && fieldCount > 5 {
		return nil, errors.New("FieldCountNotMatch")
	}

	offsets := make([]uint32, fieldCount)

	for i := 0; i < int(fieldCount); i++ {
		offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
	}
	offsets = append(offsets, uint32(totalSize))

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 && offsets[i-1] > offsets[i] {
			return nil, errors.New("OffsetsNotMatch")
		}
	}

	var err error

	_, err = Uint32FromSlice(slice[offsets[0]:offsets[1]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = Uint32FromSlice(slice[offsets[1]:offsets[2]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = Uint32FromSlice(slice[offsets[2]:offsets[3]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = Uint32FromSlice(slice[offsets[3]:offsets[4]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = Uint32FromSlice(slice[offsets[4]:offsets[5]], compatible)
	if err != nil {
		return nil, err
	}

	return &ConfigCellProfitRateV1{inner: slice}, nil
}

func (s *ConfigCellProfitRateV1) TotalSize() uint {
	return uint(unpackNumber(s.inner))
}
func (s *ConfigCellProfitRateV1) FieldCount() uint {
	var number uint = 0
	if uint32(s.TotalSize()) == HeaderSizeUint {
		return number
	}
	number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
	return number
}
func (s *ConfigCellProfitRateV1) Len() uint {
	return s.FieldCount()
}
func (s *ConfigCellProfitRateV1) IsEmpty() bool {
	return s.Len() == 0
}
func (s *ConfigCellProfitRateV1) CountExtraFields() uint {
	return s.FieldCount() - 5
}

func (s *ConfigCellProfitRateV1) HasExtraFields() bool {
	return 5 != s.FieldCount()
}

func (s *ConfigCellProfitRateV1) Inviter() *Uint32 {
	start := unpackNumber(s.inner[4:])
	end := unpackNumber(s.inner[8:])
	return Uint32FromSliceUnchecked(s.inner[start:end])
}

func (s *ConfigCellProfitRateV1) Channel() *Uint32 {
	start := unpackNumber(s.inner[8:])
	end := unpackNumber(s.inner[12:])
	return Uint32FromSliceUnchecked(s.inner[start:end])
}

func (s *ConfigCellProfitRateV1) ProposalCreate() *Uint32 {
	start := unpackNumber(s.inner[12:])
	end := unpackNumber(s.inner[16:])
	return Uint32FromSliceUnchecked(s.inner[start:end])
}

func (s *ConfigCellProfitRateV1) ProposalConfirm() *Uint32 {
	start := unpackNumber(s.inner[16:])
	end := unpackNumber(s.inner[20:])
	return Uint32FromSliceUnchecked(s.inner[start:end])
}

func (s *ConfigCellProfitRateV1) IncomeConsolidate() *Uint32 {
	var ret *Uint32
	start := unpackNumber(s.inner[20:])
	if s.HasExtraFields() {
		end := unpackNumber(s.inner[24:])
		ret = Uint32FromSliceUnchecked(s.inner[start:end])
	} else {
		ret = Uint32FromSliceUnchecked(s.inner[start:])
	}
	return ret
}

func (s *ConfigCellProfitRateV1) AsBuilder() ConfigCellProfitRateV1Builder {
	ret := NewConfigCellProfitRateV1Builder().Inviter(*s.Inviter()).Channel(*s.Channel()).ProposalCreate(*s.ProposalCreate()).ProposalConfirm(*s.ProposalConfirm()).IncomeConsolidate(*s.IncomeConsolidate())
	return *ret
}

type ConfigCellProfitRateV2Builder struct {
	inviter            Uint32
	channel            Uint32
	proposal_create    Uint32
	proposal_confirm   Uint32
	income_consolidate Uint32
	sale_inviter       Uint32
	sale_channel       Uint32
	sale_das           Uint32
}

func (s *ConfigCellProfitRateV2Builder) Build() ConfigCellProfitRateV2 {
	b := new(bytes.Buffer)

	totalSize := HeaderSizeUint * (8 + 1)
	offsets := make([]uint32, 0, 8)

	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.inviter.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.channel.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.proposal_create.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.proposal_confirm.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.income_consolidate.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.sale_inviter.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.sale_channel.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.sale_das.AsSlice()))

	b.Write(packNumber(Number(totalSize)))

	for i := 0; i < len(offsets); i++ {
		b.Write(packNumber(Number(offsets[i])))
	}

	b.Write(s.inviter.AsSlice())
	b.Write(s.channel.AsSlice())
	b.Write(s.proposal_create.AsSlice())
	b.Write(s.proposal_confirm.AsSlice())
	b.Write(s.income_consolidate.AsSlice())
	b.Write(s.sale_inviter.AsSlice())
	b.Write(s.sale_channel.AsSlice())
	b.Write(s.sale_das.AsSlice())
	return ConfigCellProfitRateV2{inner: b.Bytes()}
}

func (s *ConfigCellProfitRateV2Builder) Inviter(v Uint32) *ConfigCellProfitRateV2Builder {
	s.inviter = v
	return s
}

func (s *ConfigCellProfitRateV2Builder) Channel(v Uint32) *ConfigCellProfitRateV2Builder {
	s.channel = v
	return s
}

func (s *ConfigCellProfitRateV2Builder) ProposalCreate(v Uint32) *ConfigCellProfitRateV2Builder {
	s.proposal_create = v
	return s
}

func (s *ConfigCellProfitRateV2Builder) ProposalConfirm(v Uint32) *ConfigCellProfitRateV2Builder {
	s.proposal_confirm = v
	return s
}

func (s *ConfigCellProfitRateV2Builder) IncomeConsolidate(v Uint32) *ConfigCellProfitRateV2Builder {
	s.income_consolidate = v
	return s
}

func (s *ConfigCellProfitRateV2Builder) SaleInviter(v Uint32) *ConfigCellProfitRateV2Builder {
	s.sale_inviter = v
	return s
}

func (s *ConfigCellProfitRateV2Builder) SaleChannel(v Uint32) *ConfigCellProfitRateV2Builder {
	s.sale_channel = v
	return s
}

func (s *ConfigCellProfitRateV2Builder) SaleDas(v Uint32) *ConfigCellProfitRateV2Builder {
	s.sale_das = v
	return s
}

func NewConfigCellProfitRateV2Builder() *ConfigCellProfitRateV2Builder {
	return &ConfigCellProfitRateV2Builder{inviter: Uint32Default(), channel: Uint32Default(), proposal_create: Uint32Default(), proposal_confirm: Uint32Default(), income_consolidate: Uint32Default(), sale_inviter: Uint32Default(), sale_channel: Uint32Default(), sale_das: Uint32Default()}
}

type ConfigCellProfitRateV2 struct {
	inner []byte
}

func ConfigCellProfitRateV2FromSliceUnchecked(slice []byte) *ConfigCellProfitRateV2 {
	return &ConfigCellProfitRateV2{inner: slice}
}
func (s *ConfigCellProfitRateV2) AsSlice() []byte {
	return s.inner
}

func ConfigCellProfitRateV2Default() ConfigCellProfitRateV2 {
	return *ConfigCellProfitRateV2FromSliceUnchecked([]byte{68, 0, 0, 0, 36, 0, 0, 0, 40, 0, 0, 0, 44, 0, 0, 0, 48, 0, 0, 0, 52, 0, 0, 0, 56, 0, 0, 0, 60, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0})
}

func ConfigCellProfitRateV2FromSlice(slice []byte, compatible bool) (*ConfigCellProfitRateV2, error) {
	sliceLen := len(slice)
	if uint32(sliceLen) < HeaderSizeUint {
		errMsg := strings.Join([]string{"HeaderIsBroken", "ConfigCellProfitRateV2", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}

	totalSize := unpackNumber(slice)
	if Number(sliceLen) != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "ConfigCellProfitRateV2", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}

	if uint32(sliceLen) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "ConfigCellProfitRateV2", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	offsetFirst := unpackNumber(slice[HeaderSizeUint:])
	if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"OffsetsNotMatch", "ConfigCellProfitRateV2", strconv.Itoa(int(offsetFirst % 4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	if sliceLen < int(offsetFirst) {
		errMsg := strings.Join([]string{"HeaderIsBroken", "ConfigCellProfitRateV2", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
		return nil, errors.New(errMsg)
	}

	fieldCount := uint32(offsetFirst)/HeaderSizeUint - 1
	if fieldCount < 8 {
		return nil, errors.New("FieldCountNotMatch")
	} else if !compatible && fieldCount > 8 {
		return nil, errors.New("FieldCountNotMatch")
	}

	offsets := make([]uint32, fieldCount)

	for i := 0; i < int(fieldCount); i++ {
		offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
	}
	offsets = append(offsets, uint32(totalSize))

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 && offsets[i-1] > offsets[i] {
			return nil, errors.New("OffsetsNotMatch")
		}
	}

	var err error

	_, err = Uint32FromSlice(slice[offsets[0]:offsets[1]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = Uint32FromSlice(slice[offsets[1]:offsets[2]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = Uint32FromSlice(slice[offsets[2]:offsets[3]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = Uint32FromSlice(slice[offsets[3]:offsets[4]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = Uint32FromSlice(slice[offsets[4]:offsets[5]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = Uint32FromSlice(slice[offsets[5]:offsets[6]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = Uint32FromSlice(slice[offsets[6]:offsets[7]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = Uint32FromSlice(slice[offsets[7]:offsets[8]], compatible)
	if err != nil {
		return nil, err
	}

	return &ConfigCellProfitRateV2{inner: slice}, nil
}

func (s *ConfigCellProfitRateV2) TotalSize() uint {
	return uint(unpackNumber(s.inner))
}
func (s *ConfigCellProfitRateV2) FieldCount() uint {
	var number uint = 0
	if uint32(s.TotalSize()) == HeaderSizeUint {
		return number
	}
	number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
	return number
}
func (s *ConfigCellProfitRateV2) Len() uint {
	return s.FieldCount()
}
func (s *ConfigCellProfitRateV2) IsEmpty() bool {
	return s.Len() == 0
}
func (s *ConfigCellProfitRateV2) CountExtraFields() uint {
	return s.FieldCount() - 8
}

func (s *ConfigCellProfitRateV2) HasExtraFields() bool {
	return 8 != s.FieldCount()
}

func (s *ConfigCellProfitRateV2) Inviter() *Uint32 {
	start := unpackNumber(s.inner[4:])
	end := unpackNumber(s.inner[8:])
	return Uint32FromSliceUnchecked(s.inner[start:end])
}

func (s *ConfigCellProfitRateV2) Channel() *Uint32 {
	start := unpackNumber(s.inner[8:])
	end := unpackNumber(s.inner[12:])
	return Uint32FromSliceUnchecked(s.inner[start:end])
}

func (s *ConfigCellProfitRateV2) ProposalCreate() *Uint32 {
	start := unpackNumber(s.inner[12:])
	end := unpackNumber(s.inner[16:])
	return Uint32FromSliceUnchecked(s.inner[start:end])
}

func (s *ConfigCellProfitRateV2) ProposalConfirm() *Uint32 {
	start := unpackNumber(s.inner[16:])
	end := unpackNumber(s.inner[20:])
	return Uint32FromSliceUnchecked(s.inner[start:end])
}

func (s *ConfigCellProfitRateV2) IncomeConsolidate() *Uint32 {
	start := unpackNumber(s.inner[20:])
	end := unpackNumber(s.inner[24:])
	return Uint32FromSliceUnchecked(s.inner[start:end])
}

func (s *ConfigCellProfitRateV2) SaleInviter() *Uint32 {
	start := unpackNumber(s.inner[24:])
	end := unpackNumber(s.inner[28:])
	return Uint32FromSliceUnchecked(s.inner[start:end])
}

func (s *ConfigCellProfitRateV2) SaleChannel() *Uint32 {
	start := unpackNumber(s.inner[28:])
	end := unpackNumber(s.inner[32:])
	return Uint32FromSliceUnchecked(s.inner[start:end])
}

func (s *ConfigCellProfitRateV2) SaleDas() *Uint32 {
	var ret *Uint32
	start := unpackNumber(s.inner[32:])
	if s.HasExtraFields() {
		end := unpackNumber(s.inner[36:])
		ret = Uint32FromSliceUnchecked(s.inner[start:end])
	} else {
		ret = Uint32FromSliceUnchecked(s.inner[start:])
	}
	return ret
}

func (s *ConfigCellProfitRateV2) AsBuilder() ConfigCellProfitRateV2Builder {
	ret := NewConfigCellProfitRateV2Builder().Inviter(*s.Inviter()).Channel(*s.Channel()).ProposalCreate(*s.ProposalCreate()).ProposalConfirm(*s.ProposalConfirm()).IncomeConsolidate(*s.IncomeConsolidate()).SaleInviter(*s.SaleInviter()).SaleChannel(*s.SaleChannel()).SaleDas(*s.SaleDas())
	return *ret
}

type ConfigCellSecondaryMarketV1Builder struct {
	min_sale_price               Uint64
	sale_expiration_limit        Uint64
	sale_description_bytes_limit Uint32
}

func (s *ConfigCellSecondaryMarketV1Builder) Build() ConfigCellSecondaryMarketV1 {
	b := new(bytes.Buffer)

	totalSize := HeaderSizeUint * (3 + 1)
	offsets := make([]uint32, 0, 3)

	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.min_sale_price.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.sale_expiration_limit.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.sale_description_bytes_limit.AsSlice()))

	b.Write(packNumber(Number(totalSize)))

	for i := 0; i < len(offsets); i++ {
		b.Write(packNumber(Number(offsets[i])))
	}

	b.Write(s.min_sale_price.AsSlice())
	b.Write(s.sale_expiration_limit.AsSlice())
	b.Write(s.sale_description_bytes_limit.AsSlice())
	return ConfigCellSecondaryMarketV1{inner: b.Bytes()}
}

func (s *ConfigCellSecondaryMarketV1Builder) MinSalePrice(v Uint64) *ConfigCellSecondaryMarketV1Builder {
	s.min_sale_price = v
	return s
}

func (s *ConfigCellSecondaryMarketV1Builder) SaleExpirationLimit(v Uint64) *ConfigCellSecondaryMarketV1Builder {
	s.sale_expiration_limit = v
	return s
}

func (s *ConfigCellSecondaryMarketV1Builder) SaleDescriptionBytesLimit(v Uint32) *ConfigCellSecondaryMarketV1Builder {
	s.sale_description_bytes_limit = v
	return s
}

func NewConfigCellSecondaryMarketV1Builder() *ConfigCellSecondaryMarketV1Builder {
	return &ConfigCellSecondaryMarketV1Builder{min_sale_price: Uint64Default(), sale_expiration_limit: Uint64Default(), sale_description_bytes_limit: Uint32Default()}
}

type ConfigCellSecondaryMarketV1 struct {
	inner []byte
}

func ConfigCellSecondaryMarketV1FromSliceUnchecked(slice []byte) *ConfigCellSecondaryMarketV1 {
	return &ConfigCellSecondaryMarketV1{inner: slice}
}
func (s *ConfigCellSecondaryMarketV1) AsSlice() []byte {
	return s.inner
}

func ConfigCellSecondaryMarketV1Default() ConfigCellSecondaryMarketV1 {
	return *ConfigCellSecondaryMarketV1FromSliceUnchecked([]byte{36, 0, 0, 0, 16, 0, 0, 0, 24, 0, 0, 0, 32, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0})
}

func ConfigCellSecondaryMarketV1FromSlice(slice []byte, compatible bool) (*ConfigCellSecondaryMarketV1, error) {
	sliceLen := len(slice)
	if uint32(sliceLen) < HeaderSizeUint {
		errMsg := strings.Join([]string{"HeaderIsBroken", "ConfigCellSecondaryMarketV1", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}

	totalSize := unpackNumber(slice)
	if Number(sliceLen) != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "ConfigCellSecondaryMarketV1", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}

	if uint32(sliceLen) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "ConfigCellSecondaryMarketV1", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	offsetFirst := unpackNumber(slice[HeaderSizeUint:])
	if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"OffsetsNotMatch", "ConfigCellSecondaryMarketV1", strconv.Itoa(int(offsetFirst % 4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	if sliceLen < int(offsetFirst) {
		errMsg := strings.Join([]string{"HeaderIsBroken", "ConfigCellSecondaryMarketV1", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
		return nil, errors.New(errMsg)
	}

	fieldCount := uint32(offsetFirst)/HeaderSizeUint - 1
	if fieldCount < 3 {
		return nil, errors.New("FieldCountNotMatch")
	} else if !compatible && fieldCount > 3 {
		return nil, errors.New("FieldCountNotMatch")
	}

	offsets := make([]uint32, fieldCount)

	for i := 0; i < int(fieldCount); i++ {
		offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
	}
	offsets = append(offsets, uint32(totalSize))

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 && offsets[i-1] > offsets[i] {
			return nil, errors.New("OffsetsNotMatch")
		}
	}

	var err error

	_, err = Uint64FromSlice(slice[offsets[0]:offsets[1]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = Uint64FromSlice(slice[offsets[1]:offsets[2]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = Uint32FromSlice(slice[offsets[2]:offsets[3]], compatible)
	if err != nil {
		return nil, err
	}

	return &ConfigCellSecondaryMarketV1{inner: slice}, nil
}

func (s *ConfigCellSecondaryMarketV1) TotalSize() uint {
	return uint(unpackNumber(s.inner))
}
func (s *ConfigCellSecondaryMarketV1) FieldCount() uint {
	var number uint = 0
	if uint32(s.TotalSize()) == HeaderSizeUint {
		return number
	}
	number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
	return number
}
func (s *ConfigCellSecondaryMarketV1) Len() uint {
	return s.FieldCount()
}
func (s *ConfigCellSecondaryMarketV1) IsEmpty() bool {
	return s.Len() == 0
}
func (s *ConfigCellSecondaryMarketV1) CountExtraFields() uint {
	return s.FieldCount() - 3
}

func (s *ConfigCellSecondaryMarketV1) HasExtraFields() bool {
	return 3 != s.FieldCount()
}

func (s *ConfigCellSecondaryMarketV1) MinSalePrice() *Uint64 {
	start := unpackNumber(s.inner[4:])
	end := unpackNumber(s.inner[8:])
	return Uint64FromSliceUnchecked(s.inner[start:end])
}

func (s *ConfigCellSecondaryMarketV1) SaleExpirationLimit() *Uint64 {
	start := unpackNumber(s.inner[8:])
	end := unpackNumber(s.inner[12:])
	return Uint64FromSliceUnchecked(s.inner[start:end])
}

func (s *ConfigCellSecondaryMarketV1) SaleDescriptionBytesLimit() *Uint32 {
	var ret *Uint32
	start := unpackNumber(s.inner[12:])
	if s.HasExtraFields() {
		end := unpackNumber(s.inner[16:])
		ret = Uint32FromSliceUnchecked(s.inner[start:end])
	} else {
		ret = Uint32FromSliceUnchecked(s.inner[start:])
	}
	return ret
}

func (s *ConfigCellSecondaryMarketV1) AsBuilder() ConfigCellSecondaryMarketV1Builder {
	ret := NewConfigCellSecondaryMarketV1Builder().MinSalePrice(*s.MinSalePrice()).SaleExpirationLimit(*s.SaleExpirationLimit()).SaleDescriptionBytesLimit(*s.SaleDescriptionBytesLimit())
	return *ret
}

type ConfigCellSecondaryMarketV2Builder struct {
	sale_min_price                      Uint64
	sale_expiration_limit               Uint32
	sale_description_bytes_limit        Uint32
	auction_max_extendable_duration     Uint32
	auction_duration_increment_each_bid Uint32
	auction_min_opening_price           Uint64
	auction_min_increment_rate_each_bid Uint32
	auction_description_bytes_limit     Uint32
}

func (s *ConfigCellSecondaryMarketV2Builder) Build() ConfigCellSecondaryMarketV2 {
	b := new(bytes.Buffer)

	totalSize := HeaderSizeUint * (8 + 1)
	offsets := make([]uint32, 0, 8)

	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.sale_min_price.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.sale_expiration_limit.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.sale_description_bytes_limit.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.auction_max_extendable_duration.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.auction_duration_increment_each_bid.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.auction_min_opening_price.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.auction_min_increment_rate_each_bid.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.auction_description_bytes_limit.AsSlice()))

	b.Write(packNumber(Number(totalSize)))

	for i := 0; i < len(offsets); i++ {
		b.Write(packNumber(Number(offsets[i])))
	}

	b.Write(s.sale_min_price.AsSlice())
	b.Write(s.sale_expiration_limit.AsSlice())
	b.Write(s.sale_description_bytes_limit.AsSlice())
	b.Write(s.auction_max_extendable_duration.AsSlice())
	b.Write(s.auction_duration_increment_each_bid.AsSlice())
	b.Write(s.auction_min_opening_price.AsSlice())
	b.Write(s.auction_min_increment_rate_each_bid.AsSlice())
	b.Write(s.auction_description_bytes_limit.AsSlice())
	return ConfigCellSecondaryMarketV2{inner: b.Bytes()}
}

func (s *ConfigCellSecondaryMarketV2Builder) SaleMinPrice(v Uint64) *ConfigCellSecondaryMarketV2Builder {
	s.sale_min_price = v
	return s
}

func (s *ConfigCellSecondaryMarketV2Builder) SaleExpirationLimit(v Uint32) *ConfigCellSecondaryMarketV2Builder {
	s.sale_expiration_limit = v
	return s
}

func (s *ConfigCellSecondaryMarketV2Builder) SaleDescriptionBytesLimit(v Uint32) *ConfigCellSecondaryMarketV2Builder {
	s.sale_description_bytes_limit = v
	return s
}

func (s *ConfigCellSecondaryMarketV2Builder) AuctionMaxExtendableDuration(v Uint32) *ConfigCellSecondaryMarketV2Builder {
	s.auction_max_extendable_duration = v
	return s
}

func (s *ConfigCellSecondaryMarketV2Builder) AuctionDurationIncrementEachBid(v Uint32) *ConfigCellSecondaryMarketV2Builder {
	s.auction_duration_increment_each_bid = v
	return s
}

func (s *ConfigCellSecondaryMarketV2Builder) AuctionMinOpeningPrice(v Uint64) *ConfigCellSecondaryMarketV2Builder {
	s.auction_min_opening_price = v
	return s
}

func (s *ConfigCellSecondaryMarketV2Builder) AuctionMinIncrementRateEachBid(v Uint32) *ConfigCellSecondaryMarketV2Builder {
	s.auction_min_increment_rate_each_bid = v
	return s
}

func (s *ConfigCellSecondaryMarketV2Builder) AuctionDescriptionBytesLimit(v Uint32) *ConfigCellSecondaryMarketV2Builder {
	s.auction_description_bytes_limit = v
	return s
}

func NewConfigCellSecondaryMarketV2Builder() *ConfigCellSecondaryMarketV2Builder {
	return &ConfigCellSecondaryMarketV2Builder{sale_min_price: Uint64Default(), sale_expiration_limit: Uint32Default(), sale_description_bytes_limit: Uint32Default(), auction_max_extendable_duration: Uint32Default(), auction_duration_increment_each_bid: Uint32Default(), auction_min_opening_price: Uint64Default(), auction_min_increment_rate_each_bid: Uint32Default(), auction_description_bytes_limit: Uint32Default()}
}

type ConfigCellSecondaryMarketV2 struct {
	inner []byte
}

func ConfigCellSecondaryMarketV2FromSliceUnchecked(slice []byte) *ConfigCellSecondaryMarketV2 {
	return &ConfigCellSecondaryMarketV2{inner: slice}
}
func (s *ConfigCellSecondaryMarketV2) AsSlice() []byte {
	return s.inner
}

func ConfigCellSecondaryMarketV2Default() ConfigCellSecondaryMarketV2 {
	return *ConfigCellSecondaryMarketV2FromSliceUnchecked([]byte{76, 0, 0, 0, 36, 0, 0, 0, 44, 0, 0, 0, 48, 0, 0, 0, 52, 0, 0, 0, 56, 0, 0, 0, 60, 0, 0, 0, 68, 0, 0, 0, 72, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0})
}

func ConfigCellSecondaryMarketV2FromSlice(slice []byte, compatible bool) (*ConfigCellSecondaryMarketV2, error) {
	sliceLen := len(slice)
	if uint32(sliceLen) < HeaderSizeUint {
		errMsg := strings.Join([]string{"HeaderIsBroken", "ConfigCellSecondaryMarketV2", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}

	totalSize := unpackNumber(slice)
	if Number(sliceLen) != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "ConfigCellSecondaryMarketV2", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}

	if uint32(sliceLen) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "ConfigCellSecondaryMarketV2", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	offsetFirst := unpackNumber(slice[HeaderSizeUint:])
	if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"OffsetsNotMatch", "ConfigCellSecondaryMarketV2", strconv.Itoa(int(offsetFirst % 4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	if sliceLen < int(offsetFirst) {
		errMsg := strings.Join([]string{"HeaderIsBroken", "ConfigCellSecondaryMarketV2", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
		return nil, errors.New(errMsg)
	}

	fieldCount := uint32(offsetFirst)/HeaderSizeUint - 1
	if fieldCount < 8 {
		return nil, errors.New("FieldCountNotMatch")
	} else if !compatible && fieldCount > 8 {
		return nil, errors.New("FieldCountNotMatch")
	}

	offsets := make([]uint32, fieldCount)

	for i := 0; i < int(fieldCount); i++ {
		offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
	}
	offsets = append(offsets, uint32(totalSize))

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 && offsets[i-1] > offsets[i] {
			return nil, errors.New("OffsetsNotMatch")
		}
	}

	var err error

	_, err = Uint64FromSlice(slice[offsets[0]:offsets[1]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = Uint32FromSlice(slice[offsets[1]:offsets[2]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = Uint32FromSlice(slice[offsets[2]:offsets[3]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = Uint32FromSlice(slice[offsets[3]:offsets[4]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = Uint32FromSlice(slice[offsets[4]:offsets[5]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = Uint64FromSlice(slice[offsets[5]:offsets[6]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = Uint32FromSlice(slice[offsets[6]:offsets[7]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = Uint32FromSlice(slice[offsets[7]:offsets[8]], compatible)
	if err != nil {
		return nil, err
	}

	return &ConfigCellSecondaryMarketV2{inner: slice}, nil
}

func (s *ConfigCellSecondaryMarketV2) TotalSize() uint {
	return uint(unpackNumber(s.inner))
}
func (s *ConfigCellSecondaryMarketV2) FieldCount() uint {
	var number uint = 0
	if uint32(s.TotalSize()) == HeaderSizeUint {
		return number
	}
	number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
	return number
}
func (s *ConfigCellSecondaryMarketV2) Len() uint {
	return s.FieldCount()
}
func (s *ConfigCellSecondaryMarketV2) IsEmpty() bool {
	return s.Len() == 0
}
func (s *ConfigCellSecondaryMarketV2) CountExtraFields() uint {
	return s.FieldCount() - 8
}

func (s *ConfigCellSecondaryMarketV2) HasExtraFields() bool {
	return 8 != s.FieldCount()
}

func (s *ConfigCellSecondaryMarketV2) SaleMinPrice() *Uint64 {
	start := unpackNumber(s.inner[4:])
	end := unpackNumber(s.inner[8:])
	return Uint64FromSliceUnchecked(s.inner[start:end])
}

func (s *ConfigCellSecondaryMarketV2) SaleExpirationLimit() *Uint32 {
	start := unpackNumber(s.inner[8:])
	end := unpackNumber(s.inner[12:])
	return Uint32FromSliceUnchecked(s.inner[start:end])
}

func (s *ConfigCellSecondaryMarketV2) SaleDescriptionBytesLimit() *Uint32 {
	start := unpackNumber(s.inner[12:])
	end := unpackNumber(s.inner[16:])
	return Uint32FromSliceUnchecked(s.inner[start:end])
}

func (s *ConfigCellSecondaryMarketV2) AuctionMaxExtendableDuration() *Uint32 {
	start := unpackNumber(s.inner[16:])
	end := unpackNumber(s.inner[20:])
	return Uint32FromSliceUnchecked(s.inner[start:end])
}

func (s *ConfigCellSecondaryMarketV2) AuctionDurationIncrementEachBid() *Uint32 {
	start := unpackNumber(s.inner[20:])
	end := unpackNumber(s.inner[24:])
	return Uint32FromSliceUnchecked(s.inner[start:end])
}

func (s *ConfigCellSecondaryMarketV2) AuctionMinOpeningPrice() *Uint64 {
	start := unpackNumber(s.inner[24:])
	end := unpackNumber(s.inner[28:])
	return Uint64FromSliceUnchecked(s.inner[start:end])
}

func (s *ConfigCellSecondaryMarketV2) AuctionMinIncrementRateEachBid() *Uint32 {
	start := unpackNumber(s.inner[28:])
	end := unpackNumber(s.inner[32:])
	return Uint32FromSliceUnchecked(s.inner[start:end])
}

func (s *ConfigCellSecondaryMarketV2) AuctionDescriptionBytesLimit() *Uint32 {
	var ret *Uint32
	start := unpackNumber(s.inner[32:])
	if s.HasExtraFields() {
		end := unpackNumber(s.inner[36:])
		ret = Uint32FromSliceUnchecked(s.inner[start:end])
	} else {
		ret = Uint32FromSliceUnchecked(s.inner[start:])
	}
	return ret
}

func (s *ConfigCellSecondaryMarketV2) AsBuilder() ConfigCellSecondaryMarketV2Builder {
	ret := NewConfigCellSecondaryMarketV2Builder().SaleMinPrice(*s.SaleMinPrice()).SaleExpirationLimit(*s.SaleExpirationLimit()).SaleDescriptionBytesLimit(*s.SaleDescriptionBytesLimit()).AuctionMaxExtendableDuration(*s.AuctionMaxExtendableDuration()).AuctionDurationIncrementEachBid(*s.AuctionDurationIncrementEachBid()).AuctionMinOpeningPrice(*s.AuctionMinOpeningPrice()).AuctionMinIncrementRateEachBid(*s.AuctionMinIncrementRateEachBid()).AuctionDescriptionBytesLimit(*s.AuctionDescriptionBytesLimit())
	return *ret
}

type ConfigCellSubAccountV1Builder struct {
	basic_capacity          Uint64
	prepared_fee_capacity   Uint64
	new_sub_account_price   Uint64
	renew_sub_account_price Uint64
	common_fee              Uint64
	create_fee              Uint64
	edit_fee                Uint64
	renew_fee               Uint64
	recycle_fee             Uint64
}

func (s *ConfigCellSubAccountV1Builder) Build() ConfigCellSubAccountV1 {
	b := new(bytes.Buffer)

	totalSize := HeaderSizeUint * (9 + 1)
	offsets := make([]uint32, 0, 9)

	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.basic_capacity.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.prepared_fee_capacity.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.new_sub_account_price.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.renew_sub_account_price.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.common_fee.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.create_fee.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.edit_fee.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.renew_fee.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.recycle_fee.AsSlice()))

	b.Write(packNumber(Number(totalSize)))

	for i := 0; i < len(offsets); i++ {
		b.Write(packNumber(Number(offsets[i])))
	}

	b.Write(s.basic_capacity.AsSlice())
	b.Write(s.prepared_fee_capacity.AsSlice())
	b.Write(s.new_sub_account_price.AsSlice())
	b.Write(s.renew_sub_account_price.AsSlice())
	b.Write(s.common_fee.AsSlice())
	b.Write(s.create_fee.AsSlice())
	b.Write(s.edit_fee.AsSlice())
	b.Write(s.renew_fee.AsSlice())
	b.Write(s.recycle_fee.AsSlice())
	return ConfigCellSubAccountV1{inner: b.Bytes()}
}

func (s *ConfigCellSubAccountV1Builder) BasicCapacity(v Uint64) *ConfigCellSubAccountV1Builder {
	s.basic_capacity = v
	return s
}

func (s *ConfigCellSubAccountV1Builder) PreparedFeeCapacity(v Uint64) *ConfigCellSubAccountV1Builder {
	s.prepared_fee_capacity = v
	return s
}

func (s *ConfigCellSubAccountV1Builder) NewSubAccountPrice(v Uint64) *ConfigCellSubAccountV1Builder {
	s.new_sub_account_price = v
	return s
}

func (s *ConfigCellSubAccountV1Builder) RenewSubAccountPrice(v Uint64) *ConfigCellSubAccountV1Builder {
	s.renew_sub_account_price = v
	return s
}

func (s *ConfigCellSubAccountV1Builder) CommonFee(v Uint64) *ConfigCellSubAccountV1Builder {
	s.common_fee = v
	return s
}

func (s *ConfigCellSubAccountV1Builder) CreateFee(v Uint64) *ConfigCellSubAccountV1Builder {
	s.create_fee = v
	return s
}

func (s *ConfigCellSubAccountV1Builder) EditFee(v Uint64) *ConfigCellSubAccountV1Builder {
	s.edit_fee = v
	return s
}

func (s *ConfigCellSubAccountV1Builder) RenewFee(v Uint64) *ConfigCellSubAccountV1Builder {
	s.renew_fee = v
	return s
}

func (s *ConfigCellSubAccountV1Builder) RecycleFee(v Uint64) *ConfigCellSubAccountV1Builder {
	s.recycle_fee = v
	return s
}

func NewConfigCellSubAccountV1Builder() *ConfigCellSubAccountV1Builder {
	return &ConfigCellSubAccountV1Builder{basic_capacity: Uint64Default(), prepared_fee_capacity: Uint64Default(), new_sub_account_price: Uint64Default(), renew_sub_account_price: Uint64Default(), common_fee: Uint64Default(), create_fee: Uint64Default(), edit_fee: Uint64Default(), renew_fee: Uint64Default(), recycle_fee: Uint64Default()}
}

type ConfigCellSubAccountV1 struct {
	inner []byte
}

func ConfigCellSubAccountV1FromSliceUnchecked(slice []byte) *ConfigCellSubAccountV1 {
	return &ConfigCellSubAccountV1{inner: slice}
}
func (s *ConfigCellSubAccountV1) AsSlice() []byte {
	return s.inner
}

func ConfigCellSubAccountV1Default() ConfigCellSubAccountV1 {
	return *ConfigCellSubAccountV1FromSliceUnchecked([]byte{112, 0, 0, 0, 40, 0, 0, 0, 48, 0, 0, 0, 56, 0, 0, 0, 64, 0, 0, 0, 72, 0, 0, 0, 80, 0, 0, 0, 88, 0, 0, 0, 96, 0, 0, 0, 104, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0})
}

func ConfigCellSubAccountV1FromSlice(slice []byte, compatible bool) (*ConfigCellSubAccountV1, error) {
	sliceLen := len(slice)
	if uint32(sliceLen) < HeaderSizeUint {
		errMsg := strings.Join([]string{"HeaderIsBroken", "ConfigCellSubAccountV1", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}

	totalSize := unpackNumber(slice)
	if Number(sliceLen) != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "ConfigCellSubAccountV1", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}

	if uint32(sliceLen) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "ConfigCellSubAccountV1", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	offsetFirst := unpackNumber(slice[HeaderSizeUint:])
	if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"OffsetsNotMatch", "ConfigCellSubAccountV1", strconv.Itoa(int(offsetFirst % 4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	if sliceLen < int(offsetFirst) {
		errMsg := strings.Join([]string{"HeaderIsBroken", "ConfigCellSubAccountV1", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
		return nil, errors.New(errMsg)
	}

	fieldCount := uint32(offsetFirst)/HeaderSizeUint - 1
	if fieldCount < 9 {
		return nil, errors.New("FieldCountNotMatch")
	} else if !compatible && fieldCount > 9 {
		return nil, errors.New("FieldCountNotMatch")
	}

	offsets := make([]uint32, fieldCount)

	for i := 0; i < int(fieldCount); i++ {
		offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
	}
	offsets = append(offsets, uint32(totalSize))

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 && offsets[i-1] > offsets[i] {
			return nil, errors.New("OffsetsNotMatch")
		}
	}

	var err error

	_, err = Uint64FromSlice(slice[offsets[0]:offsets[1]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = Uint64FromSlice(slice[offsets[1]:offsets[2]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = Uint64FromSlice(slice[offsets[2]:offsets[3]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = Uint64FromSlice(slice[offsets[3]:offsets[4]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = Uint64FromSlice(slice[offsets[4]:offsets[5]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = Uint64FromSlice(slice[offsets[5]:offsets[6]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = Uint64FromSlice(slice[offsets[6]:offsets[7]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = Uint64FromSlice(slice[offsets[7]:offsets[8]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = Uint64FromSlice(slice[offsets[8]:offsets[9]], compatible)
	if err != nil {
		return nil, err
	}

	return &ConfigCellSubAccountV1{inner: slice}, nil
}

func (s *ConfigCellSubAccountV1) TotalSize() uint {
	return uint(unpackNumber(s.inner))
}
func (s *ConfigCellSubAccountV1) FieldCount() uint {
	var number uint = 0
	if uint32(s.TotalSize()) == HeaderSizeUint {
		return number
	}
	number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
	return number
}
func (s *ConfigCellSubAccountV1) Len() uint {
	return s.FieldCount()
}
func (s *ConfigCellSubAccountV1) IsEmpty() bool {
	return s.Len() == 0
}
func (s *ConfigCellSubAccountV1) CountExtraFields() uint {
	return s.FieldCount() - 9
}

func (s *ConfigCellSubAccountV1) HasExtraFields() bool {
	return 9 != s.FieldCount()
}

func (s *ConfigCellSubAccountV1) BasicCapacity() *Uint64 {
	start := unpackNumber(s.inner[4:])
	end := unpackNumber(s.inner[8:])
	return Uint64FromSliceUnchecked(s.inner[start:end])
}

func (s *ConfigCellSubAccountV1) PreparedFeeCapacity() *Uint64 {
	start := unpackNumber(s.inner[8:])
	end := unpackNumber(s.inner[12:])
	return Uint64FromSliceUnchecked(s.inner[start:end])
}

func (s *ConfigCellSubAccountV1) NewSubAccountPrice() *Uint64 {
	start := unpackNumber(s.inner[12:])
	end := unpackNumber(s.inner[16:])
	return Uint64FromSliceUnchecked(s.inner[start:end])
}

func (s *ConfigCellSubAccountV1) RenewSubAccountPrice() *Uint64 {
	start := unpackNumber(s.inner[16:])
	end := unpackNumber(s.inner[20:])
	return Uint64FromSliceUnchecked(s.inner[start:end])
}

func (s *ConfigCellSubAccountV1) CommonFee() *Uint64 {
	start := unpackNumber(s.inner[20:])
	end := unpackNumber(s.inner[24:])
	return Uint64FromSliceUnchecked(s.inner[start:end])
}

func (s *ConfigCellSubAccountV1) CreateFee() *Uint64 {
	start := unpackNumber(s.inner[24:])
	end := unpackNumber(s.inner[28:])
	return Uint64FromSliceUnchecked(s.inner[start:end])
}

func (s *ConfigCellSubAccountV1) EditFee() *Uint64 {
	start := unpackNumber(s.inner[28:])
	end := unpackNumber(s.inner[32:])
	return Uint64FromSliceUnchecked(s.inner[start:end])
}

func (s *ConfigCellSubAccountV1) RenewFee() *Uint64 {
	start := unpackNumber(s.inner[32:])
	end := unpackNumber(s.inner[36:])
	return Uint64FromSliceUnchecked(s.inner[start:end])
}

func (s *ConfigCellSubAccountV1) RecycleFee() *Uint64 {
	var ret *Uint64
	start := unpackNumber(s.inner[36:])
	if s.HasExtraFields() {
		end := unpackNumber(s.inner[40:])
		ret = Uint64FromSliceUnchecked(s.inner[start:end])
	} else {
		ret = Uint64FromSliceUnchecked(s.inner[start:])
	}
	return ret
}

func (s *ConfigCellSubAccountV1) AsBuilder() ConfigCellSubAccountV1Builder {
	ret := NewConfigCellSubAccountV1Builder().BasicCapacity(*s.BasicCapacity()).PreparedFeeCapacity(*s.PreparedFeeCapacity()).NewSubAccountPrice(*s.NewSubAccountPrice()).RenewSubAccountPrice(*s.RenewSubAccountPrice()).CommonFee(*s.CommonFee()).CreateFee(*s.CreateFee()).EditFee(*s.EditFee()).RenewFee(*s.RenewFee()).RecycleFee(*s.RecycleFee())
	return *ret
}
